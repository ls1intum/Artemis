    import org.openapitools.generator.gradle.plugin.tasks.GenerateTask
    import org.yaml.snakeyaml.Yaml


    buildscript {
        repositories {
            mavenCentral()
        }
        dependencies {
            // reuse the same version from your root project
            classpath "org.yaml:snakeyaml:${rootProject.property('snakevaml_version')}"
            classpath "org.openapitools:openapi-generator-gradle-plugin:7.12.0"
        }
    }

    openApi {
        apiDocsUrl.set("http://localhost:8080/api-docs.yaml")
        outputDir.set(file("$rootDir/openapi"))
        outputFileName.set("openapi.yaml")
        waitTimeInSeconds.set(180)
        customBootRun {
            jvmArgs = ["-Dspring.profiles.active=test,artemis,core,atlas,scheduling,athena,apollon,iris,aeolus,theia,lti," +

                           "dev","-Dspringdoc.packages-to-scan=de.tum.cit.aet.artemis.tutorialgroup.web"]

            args.set(["--artemis.user-management.use-external=false","--artemis.iris.url=http://iris.fake=",
                      "--artemis.iris.secret-token=token", "--spring.jpa.database=h2", "--spring.datasource.url=jdbc:h2:mem:mydb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE", "--spring.datasource.username=sa", --"spring.datasource.password=", "--aeolus.url=http://aeolus.fake"])

        }
    }

    openApiGenerate {
        generatorName = "typescript-angular"
        inputSpec.set(file("${rootDir}/openapi/openapi.yaml").toURI().toString())
        outputDir = "${rootDir}/src/main/webapp/app/tutorialgroup/openapi"
        apiPackage = "api"
        modelPackage = "model"
        skipValidateSpec = true
        configOptions = [
            serviceSuffix: "ApiService",
            supportsES6: "true",
            serviceFileSuffix: "Api.service"
        ]
    }
    tasks.register('pruneOpenApiSpec') {
        description = 'Prune invalid $ref nodes and drop operations (and empty paths) with missing schemas'

        doLast {
            def root       = project.rootDir
            def inputFile  = file("$root/openapi/openapi.yaml")
            def outputFile = file("$root/openapi/openapi.yaml")
            def yaml       = new Yaml()
            def spec       = yaml.load(inputFile.text) as Map<String, Object>
            def components = (spec.components ?: [:]) as Map<String, Map<String, Object>>

            // 1) Prune invalid $ref nodes
            Closure pruneRec
            pruneRec = { obj ->
                if (obj instanceof Map && obj.size() == 1 && obj.containsKey('$ref')) {
                    def ref     = obj['$ref'] as String
                    def matcher = (ref =~ /^#\/components\/([^\/]+)\/(.+)$/)
                    if (matcher.matches() && !components[matcher[0][1]]?.containsKey(matcher[0][2])) {
                        return null
                    }
                    return obj
                }
                if (obj instanceof Map) {
                    obj.collectEntries { key, val ->
                        def prunedVal = pruneRec(val)
                        prunedVal != null ? [(key): prunedVal] : [:]
                    }
                } else if (obj instanceof List) {
                    obj.collect { pruneRec(it) }.findAll { it != null }
                } else {
                    obj
                }
            }
            def prunedSpec = pruneRec(spec) as Map<String, Object>

            // 2) Drop invalid operations
            prunedSpec.paths?.with { pathsMap ->
                pathsMap.each { pathName, ops ->
                    // collect operation names to remove
                    def toRemoveOps = ops.keySet().findAll { opName ->
                        def op = ops[opName] as Map
                        // invalid if requestBody has a content type with null schema
                        def badReq  = op.requestBody?.content?.values()?.any { mt -> mt.schema == null }
                        // or any response media type has null schema
                        def badResp = op.responses?.values()?.any { resp ->
                            resp.content?.values()?.any { mt -> mt.schema == null }
                        }
                        badReq || badResp
                    }
                    // remove them
                    toRemoveOps.each { badOpName ->
                        ops.remove(badOpName)
                    }
                }
                // 3) Drop any path now left with no operations
                def emptyPaths = pathsMap.keySet().findAll { pn ->
                    (pathsMap[pn] as Map).isEmpty()
                }
                emptyPaths.each { ep ->
                    pathsMap.remove(ep)
                }
            }

            // 4) Write out the cleaned spec
            outputFile.text = yaml.dump(prunedSpec)
            println "✔ Pruned spec written to $outputFile"
        }
    }

    tasks.register('normalizeOperationIds') {
        description = 'Strip prefixes from operationId (e.g. User-update → update)'

        doLast {
            def root       = project.rootDir
            def inputFile  = file("$root/openapi/openapi-pruned.yaml")
            def outputFile = file("$root/openapi/openapi-normalized.yaml")
            def yaml       = new Yaml()
            def spec       = yaml.load(inputFile.text) as Map<String, Object>

            // Walk all paths and operations
            spec.paths?.each { path, opsMap ->
                opsMap.each { method, op ->
                    if (op.operationId instanceof String) {
                        def parts = op.operationId.split('_', 2)
                        op.operationId = parts[0]
                    }
                }
            }

            outputFile.text = yaml.dump(spec)
            println "✔ Normalized operationIds written to $outputFile"
        }
    }

    tasks.register('postProcessTsFiles') {
        description = 'Remove leading underscores and numeric suffixes from generated TS methods, and add // @ts-nocheck'

        doLast {
            def genDir = file("$project.rootDir/src/main/webapp/app/tutorialgroup/generated")
            fileTree(dir: genDir, include: '**/*.ts').each { File tsFile ->
                def content = tsFile.text

                // 1) Prepend ts-nocheck if missing
                if (!content.startsWith('// @ts-nocheck')) {
                    content = "// @ts-nocheck\n" + content
                }

                // 2) Strip leading underscores on public methods
                content = content.replaceAll(
                    /(public\s+)_+([A-Za-z_][A-Za-z0-9_]*)/,
                    '$1$2'
                )
                // 3) Strip numeric suffixes on public methods
                content = content.replaceAll(
                    /(public\s+[A-Za-z_][A-Za-z0-9_]*)_[0-9]+(\s*\()/,
                    '$1$2'
                )

                tsFile.text = content
            }
            println "✔ Post-processed TS files in $genDir"
        }
    }



//    tasks.named('pruneOpenApiSpec') {
//        dependsOn tasks.named('generateOpenApiDocs')
//    }
    //tasks.named('normalizeOperationIds') {
    //    dependsOn 'pruneOpenApiSpec'
    //}
    tasks.named('openApiGenerate') {
        dependsOn 'pruneOpenApiSpec'
    }

    tasks.named('openApiGenerate') {
        finalizedBy 'postProcessTsFiles'
    }
    tasks.named( 'openApiGenerate') {
        doFirst {
            delete file("$rootDir/src/main/webapp/app/tutorialgroup/openapi")
            println "✔ Deleted old generated files"
        }
    }
