ext {

    // Thresholds when executing each module on its own
    ModuleCoverageThresholds = [
        "assessment"   : [
            "INSTRUCTION": 0.891,
            "CLASS": 2
        ],
        "athena"       : [
            "INSTRUCTION": 0.872,
            "CLASS": 2
        ],
        "atlas"        : [
            "INSTRUCTION": 0.832,
            "CLASS": 13
        ],
        "buildagent"   : [
            "INSTRUCTION": 0.304,
            "CLASS": 13
        ],
        "communication": [
            "INSTRUCTION": 0.862,
            "CLASS": 3
        ],
        "core"         : [
            "INSTRUCTION": 0.778,
            "CLASS": 21
        ],
        "exam"         : [
            "INSTRUCTION": 0.902,
            "CLASS": 1
        ],
        "exercise"     : [
            "INSTRUCTION": 0.929,
            "CLASS": 0
        ],
        "fileupload"   : [
            "INSTRUCTION": 0.954,
            "CLASS": 0
        ],
        "iris"        : [
            "INSTRUCTION": 0.712,
            "CLASS": 22
        ],
        "lecture"      : [
            "INSTRUCTION": 0.910,
            "CLASS": 0
        ],
        "lti"          : [
            "INSTRUCTION": 0.881,
            "CLASS": 2
        ],
        "modeling"     : [
            "INSTRUCTION": 0.914,
            "CLASS": 2
        ],
        "plagiarism"   : [
            "INSTRUCTION": 0.916,
            "CLASS": 0
        ],
        "programming"  : [
            "INSTRUCTION": 0.874,
            "CLASS": 14
        ],
        "quiz"         : [
            "INSTRUCTION": 0.796,
            "CLASS": 6
        ],
        "text"         : [
            "INSTRUCTION": 0.952,
            "CLASS": 0
        ],
        "tutorialgroup": [
            "INSTRUCTION": 0.923,
            "CLASS": 0
        ],
    ]
    // If no explicit modules defined -> generate reports and validate for each module
    reportedModules = includedModules.size() == 0
        ? ModuleCoverageThresholds.collect {element -> element.key}
        : includedModules as ArrayList
}

jacoco {
    toolVersion = "0.8.12"
}

jacocoTestReport {
    reportedModules
        .collect { module -> registerJacocoReportTask(module as String, jacocoTestReport) }
        .findAll { task -> task != null}
}

jacocoTestCoverageVerification {
    // This task is just a wrapper to dynamically create tasks (per module)
    enabled = false

    reportedModules
        .collect { module -> registerJacocoTestCoverageVerification(module as String, jacocoTestCoverageVerification) }
        .findAll { task -> task != null}
}
check.dependsOn jacocoTestCoverageVerification

/**
 * Registers a JacocoReport task based on the provided parameters.
 *
 * @param moduleName The module name to include in the report.
 * @param rootTask The root JacocoReport root task.
 * @return The configured JacocoReport task.
 */
private JacocoReport registerJacocoReportTask(String moduleName, JacocoReport rootTask) {
    def taskName = "jacocoCoverageReport-$moduleName"

    JacocoReport task = project.tasks.register(taskName, JacocoReport).get()
    task.description = "Generates JaCoCo coverage report for $moduleName"

    prepareJacocoReportTask(task, moduleName, rootTask)

    task.reports {
        xml.required = true
    }

    return task
}

/**
 * Registers a JacocoCoverageVerification task based on the provided parameters.
 *
 * @param moduleName The module name to validate rules for.
 * @param rootTask The root JacocoCoverageVerification task.
 * @return The configured JacocoCoverageVerification task.
 */
private JacocoCoverageVerification registerJacocoTestCoverageVerification(String moduleName, JacocoCoverageVerification rootTask) {
    def taskName = "jacocoTestCoverageVerification-$moduleName"

    def thresholds = ModuleCoverageThresholds[moduleName]
    if (thresholds == null) {
        print "No coverage thresholds defined for module '$moduleName'. Skipping..."
        return null
    }
    def coveredInstructionRatio = thresholds.INSTRUCTION
    def missedClassCount = thresholds.CLASS

    JacocoCoverageVerification task = project.tasks.register(taskName, JacocoCoverageVerification).get()
    task.description = "Validates JaCoCo coverage for vioalations for $moduleName"

    prepareJacocoReportTask(task, moduleName, rootTask)

    task.violationRules {
        rule {
            limit {
                counter = "INSTRUCTION"
                value = "COVEREDRATIO"
                minimum = coveredInstructionRatio
            }
            limit {
                counter = "CLASS"
                value = "MISSEDCOUNT"
                maximum = missedClassCount
            }
        }
    }

    return task
}

/**
 * Prepares a Jacoco report task (report & verification) to match a specific
 * @param task that is modified
 * @param moduleName of the module.
 * @param rootTask the JacocoReportBase root task
 */
private void prepareJacocoReportTask(JacocoReportBase task, String moduleName, JacocoReportBase rootTask) {
    task.group = "Reporting"
    task.executionData = project.fileTree("${project.layout.buildDirectory.get()}/jacoco") {
        include "test.exec"
    }

    def modulePath = "$BasePath/$moduleName/**/*.class"
    task.sourceDirectories.setFrom(project.files("src/main/java/$modulePath"))
    task.classDirectories.setFrom(
        files(rootTask.classDirectories.files.collect { classDir ->
            project.fileTree(classDir) {
                includes=[modulePath]
                // we want to ignore some generated files in the domain folders
                excludes=[
                    "**/$BasePath/**/domain/**/*_*",
                    "**/$BasePath/core/config/migration/entries/**",
                    "**/gradle-wrapper.jar/**"
                ]
            }
        }
    )
    )

    task.mustRunAfter(rootTask)
}
