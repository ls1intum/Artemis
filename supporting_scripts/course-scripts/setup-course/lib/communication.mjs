/**
 * Communication data creation - posts, answers, reactions, forwarding, saved posts
 */

import { HttpClient } from './http-client.mjs';
import { authenticate } from './auth.mjs';

// Sample emojis for reactions
const EMOJIS = ['thumbsup', 'thumbsdown', 'heart', 'rocket', 'eyes', 'tada', 'fire', 'thinking', 'clap', 'laugh'];

// Sample post content templates
const POST_TEMPLATES = [
    {
        title: 'Welcome Discussion',
        content: 'Welcome to the course! Feel free to introduce yourself and share what you hope to learn.',
    },
    {
        title: 'Study Group Formation',
        content: 'Looking for study partners? Reply to this post to form study groups for the upcoming exercises.',
    },
    {
        title: 'Resource Sharing',
        content: 'Share helpful resources, tutorials, or articles related to the course topics here.',
    },
    {
        title: 'Exercise Tips',
        content: 'Having trouble with an exercise? Share your approach and help others understand the concepts.',
    },
    {
        title: 'Office Hours Reminder',
        content: 'Remember that office hours are available for additional help. Check the course schedule for times.',
    },
];

// Sample answer content templates
const ANSWER_TEMPLATES = [
    'Great question! I had the same issue and found that...',
    'Thanks for sharing this resource, it was really helpful!',
    'I agree with the approach mentioned above. Additionally, you might want to consider...',
    'This helped me understand the concept better. Here is another perspective...',
    'Excellent point! I would also add that...',
    'Just to clarify for others reading this thread...',
    'I found a similar solution that worked well for me.',
    'Thanks for the detailed explanation!',
];

/**
 * Create communication data (posts, answers, reactions, etc.)
 */
export async function createCommunicationData(client, courseId, students, studentPassword) {
    console.log('  Getting course channels...');
    const channels = await getChannels(client, courseId);

    if (!channels || channels.length === 0) {
        console.log('  No channels available for communication data');
        return { posts: [], answers: [], reactions: [] };
    }

    // Find a channel where students can post
    // Exclude announcement channels and auto-generated channels (exam, exercise, lecture channels start with special prefixes)
    let channel = channels.find((c) => {
        const name = c.name || '';
        const isAutoGenerated = name.startsWith('exam-') || name.startsWith('exercise-') || name.startsWith('lecture-');
        return (c.isCourseWide || c.isPublic) && !c.isAnnouncementChannel && !isAutoGenerated;
    });

    if (!channel) {
        // If no suitable channel found, try to create a general discussion channel
        console.log('  No suitable channel found, creating general discussion channel...');
        channel = await createGeneralChannel(client, courseId);
        if (!channel) {
            console.log('  Could not create channel, skipping communication data');
            return { posts: [], answers: [], reactions: [], forwardedMessages: [], savedPosts: [] };
        }
    }

    console.log(`  Using channel: ${channel.name}`);

    const posts = [];
    const answers = [];
    const reactions = [];
    const forwardedMessages = [];
    const savedPosts = [];

    // Create posts from different students
    console.log('  Creating posts...');
    for (let i = 0; i < Math.min(POST_TEMPLATES.length, students.length); i++) {
        const student = students[i];
        const template = POST_TEMPLATES[i];

        const studentClient = new HttpClient(client.baseUrl);
        try {
            await authenticate(studentClient, student.login, studentPassword, true);

            const post = await createPost(studentClient, courseId, channel.id, template);
            if (post) {
                posts.push(post);
                console.log(`    ${student.login}: Created post "${template.title}"`);
            }
        } catch (error) {
            const errorDetail = error.response?.data?.message || error.response?.data?.title || error.message;
            console.log(`    Could not create post as ${student.login}: ${errorDetail}`);
        }
    }

    if (posts.length === 0) {
        console.log('  No posts created, skipping answers, reactions, and other features');
        return { posts, answers, reactions, forwardedMessages, savedPosts };
    }

    // Create answer posts (replies) to existing posts
    console.log('  Creating answer posts...');
    for (let i = 0; i < Math.min(posts.length * 2, students.length); i++) {
        const student = students[i % students.length];
        const post = posts[i % posts.length];
        const answerContent = ANSWER_TEMPLATES[i % ANSWER_TEMPLATES.length];

        const studentClient = new HttpClient(client.baseUrl);
        try {
            await authenticate(studentClient, student.login, studentPassword, true);

            const answer = await createAnswerPost(studentClient, courseId, post.id, answerContent);
            if (answer) {
                answers.push(answer);
                console.log(`    ${student.login}: Replied to "${posts[i % posts.length].content?.substring(0, 30)}..."`);
            }
        } catch (error) {
            // Silently skip failed answers
        }
    }

    // Add reactions to posts and answers
    console.log('  Adding reactions...');
    for (const student of students) {
        const studentClient = new HttpClient(client.baseUrl);
        try {
            await authenticate(studentClient, student.login, studentPassword, true);

            // React to some posts
            for (let i = 0; i < Math.min(2, posts.length); i++) {
                const post = posts[(students.indexOf(student) + i) % posts.length];
                const emoji = EMOJIS[(students.indexOf(student) + i) % EMOJIS.length];

                const reaction = await addReaction(studentClient, courseId, post.id, emoji);
                if (reaction) {
                    reactions.push(reaction);
                }
            }

            // React to some answers
            if (answers.length > 0) {
                const answer = answers[students.indexOf(student) % answers.length];
                const emoji = EMOJIS[(students.indexOf(student) + 3) % EMOJIS.length];

                // Note: Answer reactions use the same endpoint but with the answer ID
                const reaction = await addReaction(studentClient, courseId, answer.id, emoji);
                if (reaction) {
                    reactions.push(reaction);
                }
            }
        } catch (error) {
            // Silently skip failed reactions
        }
    }
    console.log(`    Added ${reactions.length} reactions`);

    // Create forwarded messages
    console.log('  Creating forwarded messages...');
    if (posts.length >= 2) {
        // Forward first post to second post
        for (let i = 0; i < Math.min(2, students.length); i++) {
            const student = students[i];
            const studentClient = new HttpClient(client.baseUrl);

            try {
                await authenticate(studentClient, student.login, studentPassword, true);

                // Create a forwarded message reference from first post to second post
                const sourcePost = posts[0];
                const destPost = posts[1];

                const forwarded = await createForwardedMessage(studentClient, sourcePost.id, destPost.id);
                if (forwarded) {
                    forwardedMessages.push(forwarded);
                    console.log(`    ${student.login}: Forwarded message created`);
                }
            } catch (error) {
                const errorDetail = error.response?.data?.message || error.response?.data?.title || error.message;
                console.log(`    ${student.login}: Could not forward message: ${errorDetail}`);
            }
        }
    } else {
        console.log(`    Skipping (need at least 2 posts, have ${posts.length})`);
    }

    // Save some posts for students
    console.log('  Saving posts...');
    for (let i = 0; i < Math.min(3, students.length); i++) {
        const student = students[i];
        const post = posts[i % posts.length];

        const studentClient = new HttpClient(client.baseUrl);
        try {
            await authenticate(studentClient, student.login, studentPassword, true);

            const saved = await savePost(studentClient, post.id);
            if (saved) {
                savedPosts.push({ postId: post.id, userId: student.login });
                console.log(`    ${student.login}: Saved post`);
            }
        } catch (error) {
            // Silently skip
        }
    }

    console.log(`  Created ${posts.length} posts, ${answers.length} answers, ${reactions.length} reactions`);
    console.log(`  Created ${forwardedMessages.length} forwarded messages, ${savedPosts.length} saved posts`);

    return { posts, answers, reactions, forwardedMessages, savedPosts };
}

/**
 * Get channels for a course
 */
async function getChannels(client, courseId) {
    try {
        const response = await client.get(`/api/communication/courses/${courseId}/channels/overview`);
        return response.data || [];
    } catch (error) {
        console.log(`    Could not get channels: ${error.response?.status || error.message}`);
        return [];
    }
}

/**
 * Create a general discussion channel for students
 */
async function createGeneralChannel(client, courseId) {
    const channelData = {
        name: 'general',
        description: 'General discussion channel for all course participants',
        isPublic: true,
        isAnnouncementChannel: false,
        isCourseWide: true,
    };

    try {
        const response = await client.post(`/api/communication/courses/${courseId}/channels`, channelData);
        console.log(`    Created channel: ${response.data.name}`);
        return response.data;
    } catch (error) {
        console.log(`    Could not create channel: ${error.response?.status || error.message}`);
        return null;
    }
}

/**
 * Create a post in a channel
 */
async function createPost(client, courseId, conversationId, template) {
    const post = {
        content: template.content,
        title: template.title || null,
        hasForwardedMessages: false,
        conversation: { id: conversationId },
    };

    try {
        const response = await client.post(`/api/communication/courses/${courseId}/messages`, post);
        return response.data;
    } catch (error) {
        const errorMsg = error.response?.data?.message || error.response?.data?.title || error.message;
        throw new Error(errorMsg);
    }
}

/**
 * Create an answer post (reply) to an existing post
 */
async function createAnswerPost(client, courseId, parentPostId, content) {
    const answer = {
        content,
        post: { id: parentPostId },
    };

    try {
        const response = await client.post(`/api/communication/courses/${courseId}/answer-messages`, answer);
        return response.data;
    } catch (error) {
        return null;
    }
}

/**
 * Add a reaction to a post
 */
async function addReaction(client, courseId, postId, emojiId) {
    const reaction = {
        emojiId,
        relatedPostId: postId,
    };

    try {
        const response = await client.post(`/api/communication/courses/${courseId}/postings/reactions`, reaction);
        return response.data;
    } catch (error) {
        return null;
    }
}

/**
 * Create a forwarded message
 */
async function createForwardedMessage(client, sourcePostId, destinationPostId) {
    const forwardedMessage = {
        sourceId: sourcePostId,
        sourceType: 'POST',
        destinationPostId: destinationPostId,
    };

    try {
        const response = await client.post('/api/communication/forwarded-messages', forwardedMessage);
        return response.data;
    } catch (error) {
        return null;
    }
}

/**
 * Save a post for the current user
 */
async function savePost(client, postId) {
    try {
        await client.post(`/api/communication/saved-posts/${postId}?type=post`);
        return true;
    } catch (error) {
        return false;
    }
}
