name: Check Bean Instantiations on Startup

on:
  pull_request:
#    paths:
#      - 'src/main/java/**'

jobs:
  build:
    name: Check Bean Instantiations on Startup
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '21'

      - name: Build application
        run: ./gradlew clean bootJar -x test -x webapp

      - name: Start Spring Boot app
        run: |
          PROFILES=dev,localci,lti,aeolus,theia,iris,localvc,artemis,scheduling,buildagent,core,ldap,no-liquibase
          JAR=$(ls build/libs/Artemis*.jar | head -n1)
          nohup java -jar $JAR \
            --spring.profiles.active=dev,localci,lti,aeolus,theia,iris,localvc,artemis,scheduling,buildagent,core,ldap,no-liquibase \
            --artemis.user-management.passkey.enabled=true \
            --artemis.user-management.use-external=false \
            --artemis.iris.url=http://iris.fake \
            --artemis.iris.secret-token=token \
            --spring.liquibase.enabled=false \
            --spring.datasource.url="jdbc:h2:mem:mydb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE" \
            --spring.datasource.username=sa \
            --spring.datasource.password= \
            --eureka.client.enabled=false \
            --aeolus.url=http://aeolus.fake \
            > app.log 2>&1 &
          echo $! > app.pid

      - name: Wait for health endpoint
        run: |
          URL=http://localhost:8080/management/health/readiness
          echo "Waiting up to 60s for $URL ‚Üí HTTP 200"

          # allow curl to fail without exiting
          set +e

          HTTP_CODE=000
          for i in {1..30}; do
            # if curl fails, fallback to 000
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$URL" || echo "000")
            if [ "$HTTP_CODE" -eq 200 ]; then
              echo "‚úÖ $URL returned 200 (after $i attempts)"
              break
            fi
            echo "  attempt $i/30: HTTP $HTTP_CODE"
            sleep 2
          done

          # restore -e so failures here bubble up
          set -e

          if [ "$HTTP_CODE" -ne 200 ]; then
            echo "‚ùå Health check never returned 200; dumping full app.log:"
            cat app.log
            exit 1
          fi

      - name: Extract and validate metrics
        run: |
          LINE=$(grep 'Bean instantiation graph exported' app.log) \
            || { echo "‚ùå No metrics line"; cat app.log; exit 1; }
          echo "‚úÖ Metrics line: $LINE"
          if [[ "$LINE" =~ \(([0-9]+)\ edges,\ max\ call\ stack\ size:\ ([0-9]+)\) ]]; then
            EDGES=${BASH_REMATCH[1]}
            MAXSTACK=${BASH_REMATCH[2]}
          else
            echo "‚ùå Failed to parse numbers"; exit 1
          fi
          echo "‚Ä¢ Number of edges = $EDGES"
          echo "‚Ä¢ Max call stack size = $MAXSTACK"
          MIN_EDGES=20
          MAX_EDGES=86
          MAX_STACK_SIZE_THRESHOLD=10
          (( EDGES < MIN_EDGES )) && { echo "‚ùå < $MIN_EDGES edges"; exit 1; }
          (( EDGES > MAX_EDGES ))   && { echo "‚ùå > $MAX_EDGES edges"; exit 1; }
          (( MAXSTACK > MAX_STACK_SIZE_THRESHOLD )) && { echo "‚ùå stack > $MAX_STACK_SIZE_THRESHOLD"; exit 1; }
          echo "‚úÖ Final values ‚Üí Edges: $EDGES; Max call stack size: $MAXSTACK"
          echo "üéâ Bean metrics within expected ranges"

      - name: Stop application
        if: always()
        run: kill $(<app.pid) || true
