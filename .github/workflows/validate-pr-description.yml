name: Validate PR Description

on:
    pull_request_target:
        types: [opened, edited, ready_for_review]

jobs:
    validate-pr-description:
        # Only run on non-draft PRs targeting develop (security: prevents stacked PR attacks)
        # TODO: Remove 'github-actions/validate-pr-description-workflow' from allowed branches before merging!
        if: >
            github.event.pull_request.draft == false &&
            (github.event.pull_request.base.ref == 'develop' ||
             github.event.pull_request.base.ref == 'github-actions/validate-pr-description-workflow')
        runs-on: ubuntu-latest
        timeout-minutes: 2
        permissions:
            pull-requests: write
            contents: read

        steps:
            - name: Validate PR description
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const prNumber = context.payload.pull_request.number;
                      const owner = context.repo.owner;
                      const repo = context.repo.repo;
                      const author = context.payload.pull_request.user.login;

                      console.log(`Validating PR #${prNumber} description`);

                      // Fetch PR data
                      const { data: pr } = await github.rest.pulls.get({
                          owner,
                          repo,
                          pull_number: prNumber
                      });

                      const body = pr.body || '';

                      // Fetch changed files
                      const { data: files } = await github.rest.pulls.listFiles({
                          owner,
                          repo,
                          pull_number: prNumber,
                          per_page: 100
                      });

                      const changedFiles = files.map(f => f.filename);
                      const hasClientChanges = changedFiles.some(f => f.startsWith('src/main/webapp/'));
                      console.log(`Change types - Client: ${hasClientChanges}`);

                      // Extract sections from PR body
                      const extractSection = (header) => {
                          const regex = new RegExp(`###\\s*${header}[\\s\\S]*?(?=###|$)`, 'i');
                          const match = body.match(regex);
                          if (!match) return '';
                          // Remove the header line and HTML comments
                          return match[0]
                              .replace(/###\s*[^\n]+\n?/, '')
                              .replace(/<!--[\s\S]*?-->/g, '')
                              .trim();
                      };

                      const motivationSection = extractSection('Motivation and Context');
                      const descriptionSection = extractSection('Description');
                      const testingSection = extractSection('Steps for Testing');
                      const screenshotsSection = extractSection('Screenshots');

                      // Quick pre-checks - fail fast if sections are obviously empty
                      const issues = [];

                      if (!motivationSection || motivationSection.length < 10) {
                          issues.push('**Motivation and Context** section is empty or too brief');
                      }

                      if (!descriptionSection || descriptionSection.length < 10) {
                          issues.push('**Description** section is empty or too brief');
                      }

                      if (!testingSection || testingSection.length < 20) {
                          issues.push('**Steps for Testing** section is empty or lacks specific steps');
                      }

                      // Check if all checkboxes are unchecked (at least some should be checked)
                      const checkedBoxes = (body.match(/- \[x\]/gi) || []).length;
                      const uncheckedBoxes = (body.match(/- \[ \]/g) || []).length;
                      if (uncheckedBoxes > 0 && checkedBoxes === 0) {
                          issues.push('No checkboxes are checked in the PR description');
                      }

                      // AI validation setup
                      const azureEndpoint = '${{ secrets.PR_DESCRIPTION_VALIDATOR_OPENAI_ENDPOINT }}';
                      const azureApiKey = '${{ secrets.PR_DESCRIPTION_VALIDATOR_OPENAI_API_KEY }}';
                      const deploymentName = '${{ secrets.PR_DESCRIPTION_VALIDATOR_OPENAI_DEPLOYMENT }}';
                      const hasAiCredentials = azureEndpoint && azureApiKey && deploymentName &&
                          azureEndpoint !== '' && azureApiKey !== '';

                      // Helper function to call Azure OpenAI
                      async function callAI(systemPrompt, userPrompt) {
                          const response = await fetch(
                              `${azureEndpoint}/openai/deployments/${deploymentName}/chat/completions?api-version=2024-02-15-preview`,
                              {
                                  method: 'POST',
                                  headers: {
                                      'Content-Type': 'application/json',
                                      'api-key': azureApiKey
                                  },
                                  body: JSON.stringify({
                                      messages: [
                                          { role: 'system', content: systemPrompt },
                                          { role: 'user', content: userPrompt }
                                      ],
                                      temperature: 0,
                                      max_tokens: 50
                                  })
                              }
                          );

                          if (!response.ok) {
                              if (response.status === 429 || response.status === 503) {
                                  console.log(`AI service temporarily unavailable (${response.status})`);
                              } else {
                                  console.log(`AI request failed with status ${response.status}`);
                              }
                              return null;
                          }

                          const data = await response.json();
                          const content = data.choices?.[0]?.message?.content?.trim().toUpperCase();
                          return content;
                      }

                      // ============================================================
                      // AI CHECK 1: Content Quality (gibberish/placeholder detection)
                      // ============================================================
                      if (hasAiCredentials && motivationSection && descriptionSection) {
                          try {
                              const contentCheckPrompt = `You detect gibberish or placeholder text.

                      FAIL examples: "asdf", "xxx", "test test", "lorem ipsum", "TODO", "TBD", "fill this in", "description here", "...", random characters.

                      PASS examples: Any real sentence about code, bugs, features, or changes. Brevity is OK. Imperfect grammar is OK.

                      Reply only: PASS or FAIL`;

                              const contentInput = `Motivation: ${motivationSection.substring(0, 500)}

                      Description: ${descriptionSection.substring(0, 500)}`;

                              console.log('Running AI content quality check...');
                              const contentResult = await callAI(contentCheckPrompt, contentInput);
                              console.log(`Content quality result: ${contentResult}`);

                              if (contentResult === 'FAIL') {
                                  issues.push('**Motivation or Description** appears to contain placeholder text or gibberish');
                              }
                          } catch (error) {
                              console.log('Content quality check error (non-blocking):', error.message);
                          }
                      }

                      // ============================================================
                      // AI CHECK 2: Visual Changes Detection (only for client changes)
                      // ============================================================
                      let hasVisualChanges = false;

                      if (hasClientChanges) {
                          if (hasAiCredentials) {
                              try {
                                  const clientFiles = files.filter(f => f.filename.startsWith('src/main/webapp/'));
                                  const patchSummary = clientFiles.slice(0, 5).map(f =>
                                      `${f.filename}:\n${(f.patch || '').substring(0, 300)}`
                                  ).join('\n\n');

                                  const visualCheckPrompt = `You detect if code changes affect the UI visually.

                      VISUAL (answer YES): Changes to HTML templates, CSS/SCSS styles, component layouts, adding/removing UI elements.

                      NOT VISUAL (answer NO): TypeScript logic only, variable renames, refactoring, test files, services, utility functions, imports.

                      Reply only: YES or NO`;

                              const visualInput = `Files changed:\n${patchSummary}`;

                                  console.log('Running AI visual changes check...');
                                  const visualResult = await callAI(visualCheckPrompt, visualInput);
                                  console.log(`Visual changes result: ${visualResult}`);

                                  hasVisualChanges = visualResult === 'YES';
                              } catch (error) {
                                  console.log('Visual changes check error (non-blocking):', error.message);
                                  // Fallback to pattern matching
                                  hasVisualChanges = null;
                              }
                          }

                          // Fallback: pattern-based detection if AI unavailable or failed
                          if (hasVisualChanges === null || !hasAiCredentials) {
                              const visualFilePatterns = ['.html', '.scss', '.css'];
                              hasVisualChanges = changedFiles.some(f =>
                                  visualFilePatterns.some(pattern => f.endsWith(pattern)) &&
                                  !f.includes('.spec.')
                              );
                              console.log(`Fallback visual detection: ${hasVisualChanges}`);
                          }

                          // Check screenshots if visual changes detected
                          if (hasVisualChanges && (!screenshotsSection || screenshotsSection.length < 10)) {
                              issues.push('**Screenshots** section is empty but this PR contains visual/UI changes');
                          }
                      }

                      // Define the comment marker for identification
                      const commentMarker = '<!-- pr-description-validator -->';

                      if (issues.length > 0) {
                          console.log(`Found ${issues.length} issues with PR description`);

                          // Build comment body
                          let commentBody = `${commentMarker}\n`;
                          commentBody += `@${author} Your PR description needs attention before it can be reviewed:\n\n`;
                          commentBody += `### Issues Found\n`;
                          issues.forEach((issue, index) => {
                              commentBody += `${index + 1}. ${issue}\n`;
                          });

                          commentBody += `\n### How to Fix\n`;
                          commentBody += `- Fill in the **Motivation and Context** section explaining why this change is needed\n`;
                          commentBody += `- Add a clear **Description** of what was changed\n`;
                          commentBody += `- Provide specific **Steps for Testing** that reviewers can follow\n`;
                          if (hasClientChanges) {
                              commentBody += `- Add **Screenshots** if your changes affect the UI\n`;
                          }
                          commentBody += `- Check the relevant checkboxes in the checklist\n`;

                          commentBody += `\n---\n`;
                          commentBody += `*This check validates that your PR description follows the [PR template](https://github.com/${owner}/${repo}/blob/develop/.github/PULL_REQUEST_TEMPLATE.md). `;
                          commentBody += `A complete description helps reviewers understand your changes and speeds up the review process.*`;

                          // Post comment
                          await github.rest.issues.createComment({
                              owner,
                              repo,
                              issue_number: prNumber,
                              body: commentBody
                          });

                          core.setFailed('PR description validation failed');
                      } else {
                          console.log('PR description validation passed');

                          // Clean up any previous validation failure comments
                          try {
                              const { data: comments } = await github.rest.issues.listComments({
                                  owner,
                                  repo,
                                  issue_number: prNumber,
                                  per_page: 100
                              });

                              const botComments = comments.filter(c =>
                                  c.user.type === 'Bot' &&
                                  c.body.includes(commentMarker)
                              );

                              for (const comment of botComments) {
                                  await github.rest.issues.deleteComment({
                                      owner,
                                      repo,
                                      comment_id: comment.id
                                  });
                                  console.log(`Deleted previous validation comment ${comment.id}`);
                              }
                          } catch (error) {
                              console.log('Could not clean up old comments:', error.message);
                          }
                      }
