export const encodeUint8ArrayToBase64 = (data: Uint8Array): string => {
    let binary = '';
    const chunkSize = 0x8000;
    for (let i = 0; i < data.length; i += chunkSize) {
        binary += String.fromCharCode(...data.subarray(i, i + chunkSize));
    }
    return window.btoa(binary);
};

export const decodeBase64ToUint8Array = (base64: string): Uint8Array => {
    const binary = window.atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return bytes;
};

export type AwarenessUpdatePayload = {
    added: number[];
    updated: number[];
    removed: number[];
};

type RemoteClientStyle = {
    color: string;
    name?: string;
};

const remoteClientStyles = new Map<number, RemoteClientStyle>();
const REMOTE_STYLE_ELEMENT_ID = 'yjs-remote-selection-styles';

export const clearRemoteSelectionStyles = () => {
    remoteClientStyles.clear();
    if (typeof document === 'undefined') {
        return;
    }
    document.getElementById(REMOTE_STYLE_ELEMENT_ID)?.remove();
};

/**
 * Generate a deterministic color for a Yjs client ID.
 *
 * Uses the golden angle (~137.5°) to maximally spread hues for consecutive IDs,
 * with fixed saturation (70%) and lightness (45%).
 */
export const getColorForClientId = (clientId: number): string => {
    const hue = Math.round((Math.abs(clientId) * 137.508) % 360);
    return `hsl(${hue}, 70%, 45%)`;
};

/**
 * Validate that a color string matches a strict safe pattern to prevent CSS injection.
 *
 * Only functional notation (hex, rgb/a, hsl/a with comma-separated values) is accepted.
 * Named colors (e.g. "blue", "red") are intentionally rejected because they are ambiguous
 * with injection payloads like "red; } body { display: none }".
 * CSS4 space-separated notation (e.g. "hsl(120 50% 60%)") is not supported.
 * Colors generated by `getColorForClientId` use comma-separated hsl() and always pass validation.
 */
const validateColor = (color: string): boolean => {
    const safeColorPattern = /^(#[0-9a-fA-F]{3,8}|hsla?\(\d+,\s*\d+%,\s*\d+%(,\s*[\d.]+)?\)|rgba?\(\d+,\s*\d+,\s*\d+(,\s*[\d.]+)?\))$/;
    return safeColorPattern.test(color);
};

/**
 * Escape a string for safe use in a CSS `content: "..."` double-quoted context.
 * Single quotes are intentionally not escaped — they are safe inside double-quoted CSS strings.
 */
const escapeCssContent = (value: string): string => {
    let escaped = '';
    for (const char of value) {
        if (char === '\\') {
            escaped += '\\\\';
            continue;
        }
        if (char === '"') {
            escaped += '\\"';
            continue;
        }
        const codePoint = char.codePointAt(0) ?? 0;
        if (codePoint < 0x20 || codePoint === 0x2028 || codePoint === 0x2029) {
            escaped += `\\${codePoint.toString(16).toUpperCase().padStart(6, '0')}`;
            continue;
        }
        escaped += char;
    }
    return escaped;
};

const getInitials = (value: string): string => {
    const trimmed = value.trim();
    if (!trimmed) {
        return '';
    }
    const parts = trimmed.split(/\s+/).filter(Boolean);
    if (parts.length === 1) {
        return parts[0].slice(0, 2).toUpperCase();
    }
    return (parts[0][0] + parts[1][0]).toUpperCase();
};

const renderRemoteSelectionStyles = () => {
    if (typeof document === 'undefined') {
        return;
    }
    let styleElement = document.getElementById(REMOTE_STYLE_ELEMENT_ID) as HTMLStyleElement | null;
    if (!styleElement) {
        styleElement = document.createElement('style');
        styleElement.id = REMOTE_STYLE_ELEMENT_ID;
        document.head.appendChild(styleElement);
    }
    const rules: string[] = [];
    remoteClientStyles.forEach((style, clientId) => {
        // Validate color to prevent CSS injection, fallback to generated color if invalid
        const safeColor = style.color && validateColor(style.color) ? style.color : getColorForClientId(clientId);
        const label = style.name ? escapeCssContent(style.name) : '';
        const initials = style.name ? escapeCssContent(getInitials(style.name)) : '';
        // !important is necessary to override Monaco's inline styles for selections.
        // color-mix() is used for transparency so that any valid CSS color format (hex, hsl, rgb) works.
        rules.push(
            `
.monaco-editor .yRemoteSelection-${clientId},.yRemoteSelection-${clientId} {
    background-color:color-mix(in srgb, ${safeColor} 33%, transparent) !important;
    border-radius:2px;
    outline:1px solid color-mix(in srgb, ${safeColor} 67%, transparent) !important;
    box-shadow:inset 0 0 0 9999px color-mix(in srgb, ${safeColor} 13%, transparent);
}
.yRemoteSelectionHead-${clientId} {
    border-right:2px solid ${safeColor};
    position:relative;
}
.yRemoteSelectionHead-${clientId}::after {
    border-color:${safeColor};
}
.yRemoteSelectionHead-${clientId}::after {
    content:"${initials || label}";
    background:${safeColor};
    color:#fff;
    font-size:10px;
    line-height:1;
    border-radius:3px;
    padding:2px 4px;
    white-space:nowrap;
    position:absolute;
    left:2px;top:-18px;
    opacity:0.7;
    z-index:5;
    user-select:none;
    box-shadow:0 1px 2px rgba(0,0,0,0.25);
}
.yRemoteSelectionHead-${clientId}:hover::after {
    content:"${label}";
    opacity:0.9;
}`,
        );
    });
    styleElement.textContent = rules.join('');
};

export const ensureRemoteSelectionStyle = (rawClientId: number, color: string, displayName?: string) => {
    // Sanitize clientId before using as Map key and in CSS selectors
    const clientId = Math.abs(Math.floor(rawClientId));
    // Validate color to prevent CSS injection, fallback to generated color if invalid
    const safeColor = color && validateColor(color) ? color : getColorForClientId(clientId);
    const existing = remoteClientStyles.get(clientId);
    if (existing && existing.color === safeColor && existing.name === displayName) {
        return;
    }
    remoteClientStyles.set(clientId, { color: safeColor, name: displayName });
    renderRemoteSelectionStyles();
};
