package de.tum.cit.aet.artemis.core.service;

import static de.tum.cit.aet.artemis.core.config.Constants.PROFILE_CORE;

import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.jspecify.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.cache.CacheManager;
import org.springframework.context.annotation.Lazy;
import org.springframework.context.annotation.Profile;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import com.vdurmont.semver4j.Semver;
import com.vdurmont.semver4j.SemverException;

import de.tum.cit.aet.artemis.core.dto.CombinedSbomDTO;
import de.tum.cit.aet.artemis.core.dto.ComponentVulnerabilitiesDTO;
import de.tum.cit.aet.artemis.core.dto.ComponentWithVulnerabilitiesDTO;
import de.tum.cit.aet.artemis.core.dto.SbomComponentDTO;
import de.tum.cit.aet.artemis.core.dto.VulnerabilityDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvBatchRequestDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvBatchResponseDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvQueryDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvVulnerabilityDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvVulnerabilityResultDTO;

/**
 * Service for checking security vulnerabilities in SBOM components using the OSV.dev API.
 * <p>
 * This service queries the Open Source Vulnerabilities (OSV) database to identify known
 * security vulnerabilities in software dependencies. It supports both Maven (Java) and
 * npm (JavaScript) ecosystems.
 * <p>
 * Features:
 * <ul>
 * <li>Batch querying of up to 1000 packages per API request</li>
 * <li>Distributed caching via Hazelcast for multi-node deployments</li>
 * <li>Automatic severity classification based on CVSS scores</li>
 * <li>Support for both purl-based and name/ecosystem-based lookups</li>
 * </ul>
 *
 * @see <a href="https://osv.dev/docs/">OSV API Documentation</a>
 */
@Profile(PROFILE_CORE)
@Service
@Lazy
public class VulnerabilityService {

    private static final Logger log = LoggerFactory.getLogger(VulnerabilityService.class);

    /**
     * The OSV batch API endpoint URL.
     */
    private static final String OSV_BATCH_API_URL = "https://api.osv.dev/v1/querybatch";

    /**
     * The OSV single vulnerability API endpoint URL template.
     */
    private static final String OSV_VULN_API_URL = "https://api.osv.dev/v1/vulns/";

    /**
     * Regex pattern to extract version from version range string.
     * Example: "< 0.19.3" -> extracts "0.19.3"
     */
    private static final Pattern VERSION_RANGE_PATTERN = Pattern.compile("[<>=]+\\s*([\\d.]+.*)");

    /**
     * Cache name for storing vulnerability data in Hazelcast.
     */
    private static final String VULNERABILITY_CACHE_NAME = "sbomVulnerabilities";

    /**
     * Cache key for the combined vulnerability data.
     */
    private static final String VULNERABILITY_CACHE_KEY = "allVulnerabilities";

    private final RestTemplate restTemplate;

    private final SbomService sbomService;

    private final CacheManager cacheManager;

    /**
     * Creates a new VulnerabilityService with the required dependencies.
     *
     * @param restTemplate the REST client for making HTTP requests to the OSV API
     * @param sbomService  the service for retrieving SBOM data
     * @param cacheManager the cache manager for distributed caching (Hazelcast)
     */
    public VulnerabilityService(RestTemplate restTemplate, SbomService sbomService, CacheManager cacheManager) {
        this.restTemplate = restTemplate;
        this.sbomService = sbomService;
        this.cacheManager = cacheManager;
    }

    /**
     * Retrieves vulnerability information for all components in the SBOM.
     * <p>
     * Results are cached in a distributed cache (Hazelcast) for 24 hours to minimize
     * API calls and ensure consistent data across all application nodes.
     *
     * @return DTO containing vulnerability information for all components, including
     *         severity counts and a map of component identifiers to their vulnerabilities
     */
    public ComponentVulnerabilitiesDTO getVulnerabilities() {
        // Try to retrieve from distributed cache
        var cache = cacheManager.getCache(VULNERABILITY_CACHE_NAME);
        if (cache != null) {
            ComponentVulnerabilitiesDTO cachedResult = cache.get(VULNERABILITY_CACHE_KEY, ComponentVulnerabilitiesDTO.class);
            if (cachedResult != null) {
                log.debug("Returning cached vulnerability data from distributed cache, last checked: {}", cachedResult.lastChecked());
                return cachedResult;
            }
        }

        log.info("Fetching fresh vulnerability data from OSV API");
        ComponentVulnerabilitiesDTO result = fetchVulnerabilitiesFromOsvApi();

        // Store in distributed cache
        if (cache != null) {
            cache.put(VULNERABILITY_CACHE_KEY, result);
        }

        return result;
    }

    /**
     * Forces a refresh of vulnerability data from the OSV API, bypassing the cache.
     * <p>
     * Use this method sparingly as it makes external API calls. The refreshed data
     * will be stored in the distributed cache for subsequent requests.
     *
     * @return DTO containing fresh vulnerability information from the OSV API
     */
    public ComponentVulnerabilitiesDTO refreshVulnerabilities() {
        log.info("Force refreshing vulnerability data from OSV API");

        // Evict the cache before fetching new data
        var cache = cacheManager.getCache(VULNERABILITY_CACHE_NAME);
        if (cache != null) {
            cache.evict(VULNERABILITY_CACHE_KEY);
        }

        ComponentVulnerabilitiesDTO result = fetchVulnerabilitiesFromOsvApi();

        // Store fresh data in cache
        if (cache != null) {
            cache.put(VULNERABILITY_CACHE_KEY, result);
        }

        return result;
    }

    /**
     * Fetches vulnerability data from the OSV API for all SBOM components.
     * <p>
     * This method:
     * <ol>
     * <li>Retrieves all components from the combined SBOM (server + client)</li>
     * <li>Splits components into batches of up to 1000 (OSV API limit)</li>
     * <li>Queries the OSV batch API for each batch</li>
     * <li>Aggregates and categorizes vulnerabilities by severity</li>
     * </ol>
     *
     * @return DTO containing aggregated vulnerability data for all components
     */
    private ComponentVulnerabilitiesDTO fetchVulnerabilitiesFromOsvApi() {
        CombinedSbomDTO sbom = sbomService.getCombinedSbom();
        if (sbom == null) {
            return createEmptyVulnerabilityResult();
        }

        // Collect all components from both server and client SBOMs
        List<SbomComponentDTO> allComponents = collectAllComponents(sbom);
        if (allComponents.isEmpty()) {
            return createEmptyVulnerabilityResult();
        }

        // Query OSV API and aggregate results
        List<ComponentWithVulnerabilitiesDTO> vulnerabilitiesList = new ArrayList<>();
        int totalVulnerabilityCount = 0;
        int criticalSeverityCount = 0;
        int highSeverityCount = 0;
        int mediumSeverityCount = 0;
        int lowSeverityCount = 0;

        // Process components in batches due to OSV API limits
        for (int batchStartIndex = 0; batchStartIndex < allComponents.size(); batchStartIndex += OsvBatchRequestDTO.MAX_BATCH_SIZE) {
            int batchEndIndex = Math.min(batchStartIndex + OsvBatchRequestDTO.MAX_BATCH_SIZE, allComponents.size());
            List<SbomComponentDTO> componentBatch = allComponents.subList(batchStartIndex, batchEndIndex);

            try {
                List<ComponentWithVulnerabilitiesDTO> batchVulnerabilities = queryOsvApiForBatch(componentBatch);
                vulnerabilitiesList.addAll(batchVulnerabilities);

                // Count vulnerabilities by severity
                for (ComponentWithVulnerabilitiesDTO componentWithVulns : batchVulnerabilities) {
                    for (VulnerabilityDTO vulnerability : componentWithVulns.vulnerabilities()) {
                        totalVulnerabilityCount++;
                        switch (vulnerability.severity()) {
                            case "CRITICAL" -> criticalSeverityCount++;
                            case "HIGH" -> highSeverityCount++;
                            case "MEDIUM" -> mediumSeverityCount++;
                            case "LOW" -> lowSeverityCount++;
                            default -> {
                                // UNKNOWN severity is counted in total but not in specific categories
                            }
                        }
                    }
                }
            }
            catch (Exception e) {
                log.error("Failed to query OSV API for batch starting at index {}: {}", batchStartIndex, e.getMessage());
            }
        }

        return new ComponentVulnerabilitiesDTO(vulnerabilitiesList, totalVulnerabilityCount, criticalSeverityCount, highSeverityCount, mediumSeverityCount, lowSeverityCount,
                Instant.now().toString());
    }

    /**
     * Collects all components from both server and client SBOMs into a single list.
     *
     * @param sbom the combined SBOM containing server and client components
     * @return list of all components from both SBOMs
     */
    private List<SbomComponentDTO> collectAllComponents(CombinedSbomDTO sbom) {
        List<SbomComponentDTO> allComponents = new ArrayList<>();

        if (sbom.server() != null && sbom.server().components() != null) {
            allComponents.addAll(sbom.server().components());
        }

        if (sbom.client() != null && sbom.client().components() != null) {
            allComponents.addAll(sbom.client().components());
        }

        return allComponents;
    }

    /**
     * Queries the OSV batch API for a batch of components and parses the response.
     * <p>
     * The batch API only returns vulnerability IDs, so we need to fetch full details
     * for each vulnerability using the individual vulnerability API.
     *
     * @param components the batch of components to check (max 1000)
     * @return list of components with their vulnerabilities
     */
    private List<ComponentWithVulnerabilitiesDTO> queryOsvApiForBatch(List<SbomComponentDTO> components) {
        List<ComponentWithVulnerabilitiesDTO> vulnerabilitiesList = new ArrayList<>();

        // Build OSV batch request and track component keys for result mapping
        List<OsvQueryDTO> queries = new ArrayList<>();
        List<String> componentKeysInQueryOrder = new ArrayList<>();
        List<SbomComponentDTO> componentsInQueryOrder = new ArrayList<>();

        for (SbomComponentDTO component : components) {
            OsvQueryDTO query = buildOsvQueryForComponent(component);
            if (query != null) {
                queries.add(query);
                componentKeysInQueryOrder.add(buildComponentKey(component));
                componentsInQueryOrder.add(component);
            }
        }

        if (queries.isEmpty()) {
            return vulnerabilitiesList;
        }

        // Send batch request to OSV API
        OsvBatchRequestDTO batchRequest = new OsvBatchRequestDTO(queries);
        OsvBatchResponseDTO batchResponse = sendBatchRequestToOsvApi(batchRequest);

        if (batchResponse == null || batchResponse.results() == null) {
            return vulnerabilitiesList;
        }

        // Map OSV response back to components
        // The batch API only returns vulnerability IDs, so we need to fetch full details
        List<OsvVulnerabilityResultDTO> results = batchResponse.results();
        for (int i = 0; i < results.size() && i < componentsInQueryOrder.size(); i++) {
            OsvVulnerabilityResultDTO result = results.get(i);
            if (result.hasVulnerabilities()) {
                SbomComponentDTO component = componentsInQueryOrder.get(i);
                String componentKey = componentKeysInQueryOrder.get(i);

                // Fetch full vulnerability details for each vulnerability ID
                List<OsvVulnerabilityDTO> fullVulnerabilities = new ArrayList<>();
                for (OsvVulnerabilityDTO minimalVuln : result.vulns()) {
                    if (minimalVuln.id() != null) {
                        OsvVulnerabilityDTO fullVuln = fetchFullVulnerabilityDetails(minimalVuln.id());
                        if (fullVuln != null) {
                            fullVulnerabilities.add(fullVuln);
                        }
                    }
                }

                // Filter vulnerabilities to only include those affecting the installed version
                List<VulnerabilityDTO> vulnerabilities = convertOsvVulnerabilitiesToDTOs(fullVulnerabilities, component.version());
                if (!vulnerabilities.isEmpty()) {
                    vulnerabilitiesList.add(new ComponentWithVulnerabilitiesDTO(componentKey, vulnerabilities));
                }
            }
        }

        return vulnerabilitiesList;
    }

    /**
     * Fetches full vulnerability details from the OSV API for a specific vulnerability ID.
     * <p>
     * The batch API only returns minimal info (ID and modified date), so we need to
     * call the individual vulnerability endpoint to get full details including
     * affected ranges, severity, and database_specific fields.
     *
     * @param vulnId the vulnerability ID (e.g., "GHSA-4r6h-8v6p-xvw6")
     * @return the full vulnerability details, or null if the request failed
     */
    @Nullable
    private OsvVulnerabilityDTO fetchFullVulnerabilityDetails(String vulnId) {
        try {
            String url = OSV_VULN_API_URL + vulnId;
            OsvVulnerabilityDTO vulnerability = restTemplate.getForObject(url, OsvVulnerabilityDTO.class);
            if (vulnerability != null) {
                log.debug("Fetched full details for vulnerability {}: databaseSpecific={}, affected={}", vulnId,
                        vulnerability.databaseSpecific() != null ? "present (severity=" + vulnerability.databaseSpecific().severity() + ")" : "null",
                        vulnerability.affected() != null ? vulnerability.affected().size() + " entries" : "null");
            }
            return vulnerability;
        }
        catch (RestClientException e) {
            log.warn("Failed to fetch vulnerability details for {}: {}", vulnId, e.getMessage());
            return null;
        }
    }

    /**
     * Builds an OSV query for a single component.
     * <p>
     * Prefers purl-based queries when available, falls back to name/ecosystem/version queries.
     *
     * @param component the component to create a query for
     * @return the OSV query, or null if the component cannot be queried
     */
    @Nullable
    private OsvQueryDTO buildOsvQueryForComponent(SbomComponentDTO component) {
        // Prefer purl-based query if available
        if (component.purl() != null && !component.purl().isEmpty()) {
            return OsvQueryDTO.fromPurl(component.purl());
        }

        // Fall back to name/ecosystem/version query
        String ecosystem = determineEcosystemFromComponent(component);
        if (ecosystem != null && component.name() != null && component.version() != null) {
            String packageName = buildPackageNameForEcosystem(component, ecosystem);
            return OsvQueryDTO.fromNameAndVersion(packageName, ecosystem, component.version());
        }

        return null;
    }

    /**
     * Sends a batch request to the OSV API and returns the parsed response.
     *
     * @param batchRequest the batch request containing package queries
     * @return the parsed batch response, or null if the request failed
     */
    @Nullable
    private OsvBatchResponseDTO sendBatchRequestToOsvApi(OsvBatchRequestDTO batchRequest) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);
            HttpEntity<OsvBatchRequestDTO> request = new HttpEntity<>(batchRequest, headers);

            return restTemplate.postForObject(OSV_BATCH_API_URL, request, OsvBatchResponseDTO.class);
        }
        catch (RestClientException e) {
            log.error("OSV API request failed: {}", e.getMessage());
            return null;
        }
    }

    /**
     * Converts a list of OSV vulnerability DTOs to the application's VulnerabilityDTO format.
     * Filters out vulnerabilities that don't affect the installed component version.
     *
     * @param osvVulnerabilities the vulnerabilities from the OSV API
     * @param componentVersion   the installed version of the component to check against
     * @return list of converted vulnerability DTOs that affect the installed version
     */
    private List<VulnerabilityDTO> convertOsvVulnerabilitiesToDTOs(List<OsvVulnerabilityDTO> osvVulnerabilities, String componentVersion) {
        List<VulnerabilityDTO> vulnerabilities = new ArrayList<>();

        for (OsvVulnerabilityDTO osvVuln : osvVulnerabilities) {
            // Check if this vulnerability actually affects the installed version
            if (!isVersionAffectedByVulnerability(componentVersion, osvVuln)) {
                log.debug("Skipping vulnerability {} as it doesn't affect version {}", osvVuln.id(), componentVersion);
                continue;
            }

            String severity = determineSeverityFromOsvVulnerability(osvVuln);
            Double cvssScore = extractCvssScoreFromOsvVulnerability(osvVuln);
            List<String> fixedVersions = extractFixedVersionsFromOsvVulnerability(osvVuln);
            List<String> referenceUrls = extractReferenceUrlsFromOsvVulnerability(osvVuln);

            vulnerabilities.add(new VulnerabilityDTO(osvVuln.id(), osvVuln.summary(), osvVuln.details(), severity, cvssScore, osvVuln.aliases(), fixedVersions, referenceUrls));
        }

        return vulnerabilities;
    }

    /**
     * Checks if a specific component version is affected by a vulnerability.
     * <p>
     * Examines the vulnerability's affected ranges and version events to determine
     * if the installed version falls within the vulnerable range.
     *
     * @param componentVersion the installed version of the component
     * @param vulnerability    the OSV vulnerability to check
     * @return true if the version is affected, false if the version is safe
     */
    private boolean isVersionAffectedByVulnerability(String componentVersion, OsvVulnerabilityDTO vulnerability) {
        if (componentVersion == null || vulnerability.affected() == null) {
            // If we can't determine the version, assume vulnerable for safety
            log.warn("Cannot determine affected status for {}: componentVersion={}, affected={}", vulnerability.id(), componentVersion,
                    vulnerability.affected() != null ? "present" : "null");
            return true;
        }

        try {
            Semver installedVersion = new Semver(componentVersion, Semver.SemverType.NPM);
            log.info("Checking if version {} is affected by {}", componentVersion, vulnerability.id());

            for (OsvVulnerabilityDTO.OsvAffectedDTO affected : vulnerability.affected()) {
                log.info("  Affected entry: databaseSpecific={}, ranges={}", affected.databaseSpecific() != null ? "present" : "null",
                        affected.ranges() != null ? affected.ranges().size() + " ranges" : "null");
                if (affected.databaseSpecific() != null) {
                    log.info("    lastKnownAffectedVersionRange: {}", affected.databaseSpecific().lastKnownAffectedVersionRange());
                }
                if (isVersionInAffectedRange(installedVersion, affected)) {
                    log.info("  Result: AFFECTED");
                    return true;
                }
            }

            // None of the affected ranges matched, version is safe
            log.info("  Result: SAFE (no affected ranges matched)");
            return false;
        }
        catch (SemverException e) {
            // If version parsing fails, assume vulnerable for safety
            log.warn("Failed to parse version '{}': {}", componentVersion, e.getMessage());
            return true;
        }
    }

    /**
     * Checks if a version falls within an affected range.
     *
     * @param installedVersion the parsed semver of the installed component
     * @param affected         the affected range from the vulnerability
     * @return true if the version is within the affected range
     */
    private boolean isVersionInAffectedRange(Semver installedVersion, OsvVulnerabilityDTO.OsvAffectedDTO affected) {
        if (affected.ranges() == null) {
            log.info("    No ranges in affected entry, assuming affected");
            return true;
        }

        // First, check last_known_affected_version_range from database_specific at the affected level
        // This is the most reliable indicator from GitHub Advisory Database
        if (affected.databaseSpecific() != null && affected.databaseSpecific().lastKnownAffectedVersionRange() != null) {
            String rangeStr = affected.databaseSpecific().lastKnownAffectedVersionRange();
            log.info("    Checking lastKnownAffectedVersionRange: '{}' against version '{}'", rangeStr, installedVersion.getValue());
            Boolean rangeResult = checkVersionAgainstRangeString(installedVersion, rangeStr);
            if (rangeResult != null) {
                log.info("    lastKnownAffectedVersionRange result: affected={}", rangeResult);
                return rangeResult;
            }
            else {
                log.info("    Could not parse lastKnownAffectedVersionRange");
            }
        }
        else {
            log.info("    No lastKnownAffectedVersionRange available");
        }

        for (OsvVulnerabilityDTO.OsvRangeDTO range : affected.ranges()) {
            // Only process SEMVER and ECOSYSTEM ranges
            if (!"SEMVER".equals(range.type()) && !"ECOSYSTEM".equals(range.type())) {
                continue;
            }

            if (range.events() == null || range.events().isEmpty()) {
                continue;
            }

            // Check version events to determine if affected
            String introducedVersion = null;
            String fixedVersion = null;
            String lastAffectedVersion = null;

            for (OsvVulnerabilityDTO.OsvEventDTO event : range.events()) {
                if (event.introduced() != null) {
                    introducedVersion = event.introduced();
                }
                if (event.fixed() != null) {
                    fixedVersion = event.fixed();
                }
                if (event.limit() != null) {
                    lastAffectedVersion = event.limit();
                }
            }

            // If introduced is present and our version is below it, this range doesn't apply
            if (introducedVersion != null && !"0".equals(introducedVersion)) {
                try {
                    Semver introduced = new Semver(introducedVersion, Semver.SemverType.NPM);
                    if (installedVersion.isLowerThan(introduced)) {
                        log.debug("Version {} is < introduced version {}, skipping range", installedVersion.getValue(), introducedVersion);
                        continue;
                    }
                }
                catch (SemverException e) {
                    log.debug("Failed to parse introduced version '{}': {}", introducedVersion, e.getMessage());
                }
            }

            // If there's a fixed version and our version is >= fixed, we're safe for this range
            if (fixedVersion != null) {
                try {
                    Semver fixed = new Semver(fixedVersion, Semver.SemverType.NPM);
                    if (installedVersion.isGreaterThanOrEqualTo(fixed)) {
                        log.debug("Version {} is >= fixed version {}, skipping range", installedVersion.getValue(), fixedVersion);
                        continue;
                    }
                    else {
                        log.debug("Version {} is < fixed version {}, affected", installedVersion.getValue(), fixedVersion);
                        return true; // Version is < fixed version, affected
                    }
                }
                catch (SemverException e) {
                    log.debug("Failed to parse fixed version '{}': {}", fixedVersion, e.getMessage());
                }
            }

            // If there's a last_affected/limit version
            if (lastAffectedVersion != null) {
                try {
                    Semver lastAffected = new Semver(lastAffectedVersion, Semver.SemverType.NPM);
                    if (installedVersion.isGreaterThan(lastAffected)) {
                        log.debug("Version {} is > last affected version {}, skipping range", installedVersion.getValue(), lastAffectedVersion);
                        continue;
                    }
                    return true;
                }
                catch (SemverException e) {
                    log.debug("Failed to parse last affected version '{}': {}", lastAffectedVersion, e.getMessage());
                }
            }

            // If there's an introduced version but no fix/limit, vulnerability affects all versions from introduced onward
            if (introducedVersion != null && fixedVersion == null && lastAffectedVersion == null) {
                // Without fix info and no lastKnownAffectedVersionRange (already checked above), assume affected
                log.debug("Version {} has no fix info available, assuming affected from {}", installedVersion.getValue(), introducedVersion);
                return true;
            }
        }

        // If we processed ranges but couldn't determine status, default to not affected
        // (we already checked lastKnownAffectedVersionRange which is the most reliable indicator)
        log.debug("Could not determine affected status for version {}, defaulting to not affected", installedVersion.getValue());
        return false;
    }

    /**
     * Checks if the installed version matches a version range string like "< 0.19.3" or "<= 1.2.0".
     *
     * @param installedVersion the installed version to check
     * @param rangeStr         the version range string (e.g., "< 0.19.3", "<= 1.2.0")
     * @return true if the version is affected (within the range), false if safe (outside range), null if cannot determine
     */
    @Nullable
    private Boolean checkVersionAgainstRangeString(Semver installedVersion, String rangeStr) {
        String extractedVersion = extractVersionFromRangeString(rangeStr);
        if (extractedVersion == null) {
            return null;
        }

        try {
            Semver boundaryVersion = new Semver(extractedVersion, Semver.SemverType.NPM);

            // Handle "< X.Y.Z" (exclusive): versions less than X.Y.Z are affected
            if (rangeStr.contains("<") && !rangeStr.contains("<=")) {
                // If our version >= boundary, we're safe (not affected)
                return !installedVersion.isGreaterThanOrEqualTo(boundaryVersion);
            }

            // Handle "<= X.Y.Z" (inclusive): versions up to and including X.Y.Z are affected
            if (rangeStr.contains("<=")) {
                // If our version > boundary, we're safe (not affected)
                return !installedVersion.isGreaterThan(boundaryVersion);
            }

            // Handle "> X.Y.Z" (exclusive): versions greater than X.Y.Z are affected
            if (rangeStr.contains(">") && !rangeStr.contains(">=")) {
                return installedVersion.isGreaterThan(boundaryVersion);
            }

            // Handle ">= X.Y.Z" (inclusive): versions >= X.Y.Z are affected
            if (rangeStr.contains(">=")) {
                return installedVersion.isGreaterThanOrEqualTo(boundaryVersion);
            }
        }
        catch (SemverException e) {
            log.debug("Failed to parse version from range '{}': {}", rangeStr, e.getMessage());
        }

        return null;
    }

    /**
     * Extracts the version number from a range string like "< 0.19.3" or "<= 1.2.0".
     *
     * @param rangeString the version range string
     * @return the extracted version, or null if extraction fails
     */
    @Nullable
    private String extractVersionFromRangeString(String rangeString) {
        if (rangeString == null) {
            return null;
        }

        Matcher matcher = VERSION_RANGE_PATTERN.matcher(rangeString.trim());
        if (matcher.find()) {
            return matcher.group(1).trim();
        }

        return null;
    }

    /**
     * Determines the severity level from an OSV vulnerability.
     * <p>
     * Priority order:
     * <ol>
     * <li>Database-specific severity (most reliable for GitHub Advisory Database)</li>
     * <li>Numeric CVSS scores</li>
     * <li>Estimated severity from CVSS vector strings</li>
     * <li>Severity from affected entries' database_specific</li>
     * </ol>
     *
     * @param vulnerability the OSV vulnerability
     * @return the severity level (CRITICAL, HIGH, MEDIUM, LOW, or UNKNOWN)
     */
    private String determineSeverityFromOsvVulnerability(OsvVulnerabilityDTO vulnerability) {
        // Priority 1: Check database-specific severity (most reliable for GHSA advisories)
        if (vulnerability.databaseSpecific() != null && vulnerability.databaseSpecific().severity() != null) {
            String dbSeverity = vulnerability.databaseSpecific().severity().toUpperCase();
            log.debug("Found database_specific severity for {}: {}", vulnerability.id(), dbSeverity);
            if (isValidSeverity(dbSeverity)) {
                return normalizeSeverity(dbSeverity);
            }
        }
        else {
            log.debug("No database_specific severity for {}, databaseSpecific={}", vulnerability.id(),
                    vulnerability.databaseSpecific() != null ? "present but no severity" : "null");
        }

        // Priority 2: Try to extract numeric CVSS score or estimate from vector
        if (vulnerability.severity() != null && !vulnerability.severity().isEmpty()) {
            for (OsvVulnerabilityDTO.OsvSeverityDTO severityEntry : vulnerability.severity()) {
                log.debug("Checking severity entry for {}: type={}, score={}", vulnerability.id(), severityEntry.type(), severityEntry.score());
                // Handle CVSS v2, v3, and v4
                if (severityEntry.type() != null && severityEntry.type().startsWith("CVSS")) {
                    Double cvssScore = parseCvssScore(severityEntry.score());
                    if (cvssScore != null) {
                        String severity = mapCvssScoreToSeverity(cvssScore);
                        log.debug("Mapped CVSS score {} to severity {} for {}", cvssScore, severity, vulnerability.id());
                        return severity;
                    }

                    // Estimate severity from CVSS vector string (v3 or v4)
                    String vectorSeverity = estimateSeverityFromCvssVector(severityEntry.score());
                    if (vectorSeverity != null) {
                        log.debug("Estimated severity {} from CVSS vector for {}", vectorSeverity, vulnerability.id());
                        return vectorSeverity;
                    }
                }
            }
        }
        else {
            log.debug("No severity array for {}", vulnerability.id());
        }

        // Priority 3: Check affected entries for severity info (some GHSA entries have it there)
        if (vulnerability.affected() != null) {
            for (OsvVulnerabilityDTO.OsvAffectedDTO affected : vulnerability.affected()) {
                if (affected.databaseSpecific() != null) {
                    // The affected database_specific might have additional severity info in future
                    log.debug("Affected entry databaseSpecific for {}: lastKnownAffectedVersionRange={}", vulnerability.id(),
                            affected.databaseSpecific().lastKnownAffectedVersionRange());
                }
            }
        }

        log.debug("Could not determine severity for {}, returning UNKNOWN", vulnerability.id());
        return "UNKNOWN";
    }

    /**
     * Checks if a severity string is a valid severity level.
     *
     * @param severity the severity string to check
     * @return true if it's a valid severity level
     */
    private boolean isValidSeverity(String severity) {
        return "CRITICAL".equals(severity) || "HIGH".equals(severity) || "MEDIUM".equals(severity) || "LOW".equals(severity) || "MODERATE".equals(severity);
    }

    /**
     * Normalizes severity string to standard values.
     * Maps GHSA-style "MODERATE" to "MEDIUM".
     *
     * @param severity the severity string to normalize
     * @return normalized severity string
     */
    private String normalizeSeverity(String severity) {
        if ("MODERATE".equals(severity)) {
            return "MEDIUM";
        }
        return severity;
    }

    /**
     * Estimates severity from a CVSS vector string by analyzing the impact metrics.
     * <p>
     * Supports CVSS v3.x and v4.0 vector formats.
     * This is a simplified estimation based on the Confidentiality, Integrity, and Availability
     * impact metrics. For accurate scoring, a full CVSS calculator would be needed.
     *
     * @param cvssVector the CVSS vector string (e.g., "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H")
     * @return estimated severity, or null if the vector cannot be parsed
     */
    @Nullable
    private String estimateSeverityFromCvssVector(String cvssVector) {
        if (cvssVector == null || !cvssVector.startsWith("CVSS:")) {
            return null;
        }

        // Handle CVSS v4.0 format (uses VC:H, VI:H, VA:H for vulnerability impact)
        boolean isCvss4 = cvssVector.startsWith("CVSS:4");

        // Count high impact metrics
        final var highImpactCount = getHighImpactCount(cvssVector, isCvss4);

        // Check attack vector and privileges required (same for v3 and v4)
        boolean networkAttack = cvssVector.contains("/AV:N");
        boolean noPrivilegesRequired = cvssVector.contains("/PR:N");
        boolean noUserInteraction = cvssVector.contains("/UI:N");

        // Estimate severity based on impact and exploitability
        if (highImpactCount == 3 && networkAttack && noPrivilegesRequired) {
            return "CRITICAL";
        }
        if (highImpactCount >= 2 && networkAttack) {
            return "HIGH";
        }
        if (highImpactCount >= 1) {
            return networkAttack && noUserInteraction ? "HIGH" : "MEDIUM";
        }

        // Check for low/medium impacts
        if (isCvss4) {
            if (cvssVector.contains("/VC:L") || cvssVector.contains("/VI:L") || cvssVector.contains("/VA:L")) {
                return "LOW";
            }
        }
        else {
            if (cvssVector.contains("/C:L") || cvssVector.contains("/I:L") || cvssVector.contains("/A:L")) {
                return "LOW";
            }
        }

        return "MEDIUM"; // Default to medium if we can parse but can't determine
    }

    private static int getHighImpactCount(String cvssVector, boolean isCvss4) {
        int highImpactCount = 0;
        if (isCvss4) {
            // CVSS v4 uses VC (Vulnerable Confidentiality), VI (Vulnerable Integrity), VA (Vulnerable Availability)
            if (cvssVector.contains("/VC:H")) {
                highImpactCount++;
            }
            if (cvssVector.contains("/VI:H")) {
                highImpactCount++;
            }
            if (cvssVector.contains("/VA:H")) {
                highImpactCount++;
            }
        }
        else {
            // CVSS v3.x uses C:H, I:H, A:H
            if (cvssVector.contains("/C:H")) {
                highImpactCount++;
            }
            if (cvssVector.contains("/I:H")) {
                highImpactCount++;
            }
            if (cvssVector.contains("/A:H")) {
                highImpactCount++;
            }
        }
        return highImpactCount;
    }

    /**
     * Extracts the CVSS score from an OSV vulnerability.
     *
     * @param vulnerability the OSV vulnerability
     * @return the CVSS score, or null if not available
     */
    @Nullable
    private Double extractCvssScoreFromOsvVulnerability(OsvVulnerabilityDTO vulnerability) {
        if (vulnerability.severity() == null) {
            return null;
        }

        for (OsvVulnerabilityDTO.OsvSeverityDTO severityEntry : vulnerability.severity()) {
            if ("CVSS_V3".equals(severityEntry.type()) || "CVSS_V2".equals(severityEntry.type())) {
                return parseCvssScore(severityEntry.score());
            }
        }

        return null;
    }

    /**
     * Extracts fixed versions from an OSV vulnerability.
     *
     * @param vulnerability the OSV vulnerability
     * @return list of versions where the vulnerability is fixed
     */
    private List<String> extractFixedVersionsFromOsvVulnerability(OsvVulnerabilityDTO vulnerability) {
        List<String> fixedVersions = new ArrayList<>();

        if (vulnerability.affected() == null) {
            return fixedVersions;
        }

        for (OsvVulnerabilityDTO.OsvAffectedDTO affected : vulnerability.affected()) {
            if (affected.ranges() == null) {
                continue;
            }

            for (OsvVulnerabilityDTO.OsvRangeDTO range : affected.ranges()) {
                if (range.events() == null) {
                    continue;
                }

                for (OsvVulnerabilityDTO.OsvEventDTO event : range.events()) {
                    if (event.fixed() != null && !fixedVersions.contains(event.fixed())) {
                        fixedVersions.add(event.fixed());
                    }
                }
            }
        }

        return fixedVersions;
    }

    /**
     * Extracts reference URLs from an OSV vulnerability.
     *
     * @param vulnerability the OSV vulnerability
     * @return list of reference URLs
     */
    private List<String> extractReferenceUrlsFromOsvVulnerability(OsvVulnerabilityDTO vulnerability) {
        List<String> urls = new ArrayList<>();

        if (vulnerability.references() == null) {
            return urls;
        }

        for (OsvVulnerabilityDTO.OsvReferenceDTO reference : vulnerability.references()) {
            if (reference.url() != null) {
                urls.add(reference.url());
            }
        }

        return urls;
    }

    /**
     * Parses a CVSS score from a string value.
     * <p>
     * Handles both direct numeric scores and CVSS vector strings.
     *
     * @param cvssString the CVSS score or vector string
     * @return the parsed numeric score, or null if parsing fails
     */
    @Nullable
    private Double parseCvssScore(String cvssString) {
        if (cvssString == null) {
            return null;
        }

        try {
            return Double.parseDouble(cvssString);
        }
        catch (NumberFormatException e) {
            // CVSS vector strings cannot be parsed without a dedicated library
            return null;
        }
    }

    /**
     * Maps a CVSS score to a severity level according to CVSS v3.1 specification.
     *
     * @param cvssScore the CVSS score (0.0-10.0)
     * @return the corresponding severity level
     * @see <a href="https://nvd.nist.gov/vuln-metrics/cvss">CVSS Severity Ratings</a>
     */
    private String mapCvssScoreToSeverity(Double cvssScore) {
        if (cvssScore >= 9.0) {
            return "CRITICAL";
        }
        if (cvssScore >= 7.0) {
            return "HIGH";
        }
        if (cvssScore >= 4.0) {
            return "MEDIUM";
        }
        if (cvssScore >= 0.1) {
            return "LOW";
        }
        return "UNKNOWN";
    }

    /**
     * Determines the package ecosystem from a component's metadata.
     * <p>
     * Uses purl prefix or group naming conventions to identify the ecosystem.
     *
     * @param component the SBOM component
     * @return the ecosystem name (Maven, npm, PyPI, Go) or null if unknown
     */
    @Nullable
    private String determineEcosystemFromComponent(SbomComponentDTO component) {
        String purl = component.purl();
        if (purl != null) {
            if (purl.startsWith("pkg:maven/")) {
                return "Maven";
            }
            if (purl.startsWith("pkg:npm/")) {
                return "npm";
            }
            if (purl.startsWith("pkg:pypi/")) {
                return "PyPI";
            }
            if (purl.startsWith("pkg:golang/")) {
                return "Go";
            }
        }

        // Heuristic based on group naming conventions
        String group = component.group();
        if (group != null) {
            // Java packages typically have reverse domain name groups
            if (group.contains(".") || group.startsWith("org.") || group.startsWith("com.") || group.startsWith("io.") || group.startsWith("de.")) {
                return "Maven";
            }
            // npm scoped packages start with @
            if (group.startsWith("@")) {
                return "npm";
            }
        }

        return null;
    }

    /**
     * Builds the package name in the format expected by the OSV API for the given ecosystem.
     *
     * @param component the SBOM component
     * @param ecosystem the package ecosystem
     * @return the formatted package name
     */
    private String buildPackageNameForEcosystem(SbomComponentDTO component, String ecosystem) {
        // Maven packages require "group:artifact" format
        if ("Maven".equals(ecosystem) && component.group() != null && !component.group().isEmpty()) {
            return component.group() + ":" + component.name();
        }
        return component.name();
    }

    /**
     * Builds a unique key for a component to use in the vulnerability map.
     * <p>
     * Uses purl if available, otherwise constructs a synthetic key from ecosystem, group, name, and version.
     *
     * @param component the SBOM component
     * @return a unique key identifying the component
     */
    private String buildComponentKey(SbomComponentDTO component) {
        if (component.purl() != null && !component.purl().isEmpty()) {
            return component.purl();
        }

        String ecosystem = determineEcosystemFromComponent(component);
        String group = component.group() != null ? component.group() : "";
        return ecosystem + ":" + group + "/" + component.name() + "@" + component.version();
    }

    /**
     * Creates an empty vulnerability result with zero counts.
     *
     * @return an empty ComponentVulnerabilitiesDTO
     */
    private ComponentVulnerabilitiesDTO createEmptyVulnerabilityResult() {
        return new ComponentVulnerabilitiesDTO(List.of(), 0, 0, 0, 0, 0, Instant.now().toString());
    }
}
