{{#system~}}The following is a work-in-progress programming exercise.{{~/system}}

{{#system~}}The template repository:{{~/system}}
{{#each templateRepository}}
    {{#system~}}"{{@key}}":{{~/system}}
    {{#user~}}{{this}}{{~/user}}
{{/each}}
{{#system~}}End of template repository.{{~/system}}

{{#system~}}The solution repository:{{~/system}}
{{#each solutionRepository}}
    {{#system~}}"{{@key}}":{{~/system}}
    {{#user~}}{{this}}{{~/user}}
{{/each}}
{{#system~}}End of solution repository.{{~/system}}

{{#system~}}The test repository:{{~/system}}
{{#each testRepository}}
    {{#system~}}"{{@key}}":{{~/system}}
    {{#user~}}{{this}}{{~/user}}
{{/each}}
{{#system~}}End of test repository.{{~/system}}

{{#system~}}
    The problem statement of an exercise provides the students with an overview of the exercise.
    It typically starts with an engaging thematic story hook to introduce the technical content of the exercise.
    Then it gives a detailed description of the system to be implemented, which trains the students on a specific programming skill.
    The expected behavior of the program is illustrated with sample input values and their corresponding output values.
    It is also possible to include a UML class diagram in PlantUML syntax illustrating the system to be implemented and the relationships between its components.
    Do not surround the UML diagram with ```.
    The problem statement is formatted in Markdown, and always starts with the title of the exercise in bold.

    The tasks to be completed are listed with their associated test cases and clearly explained.
    For example:
    "1. [task][Implement Pet Class](testPetClassExists(), testPetClassHasAttributes(), testPetClassHasMethods()){}
    Create a new Java class called Pet. A pet has a name, a species, and a weight. Its name and species are Strings,
    while its weight is a double representing kilograms. Include a constructor and getters and setters for all three attributes."
    "2. [task][Filter, Sort, and Map Lists](testFilter(), testSort(), testMap()){}
    Implement the filter, sort, and map methods. The filter method takes a list of `T` and a `Predicate<T>` as parameters,
        and returns a list of `T` containing only the elements of the original list for which the predicate returns
        true. The sort method takes a list of `T` and a `Comparator<T>` as parameters, and returns a list of `T` containing the elements
        of the original list sorted according to the comparator. The map method takes a list of `T` and a `Function<T, R>` as parameters,
        and returns a list of `R` containing the results of applying the function to each element of the original list."
        "3. [task][Lagrange Interpolation](testLagrangeInterpolation()){}
        Implement the lagrangeInterpolation method. The method takes a list of `Point` and a `double` as parameters,
        and returns a `double` representing the y-value of the interpolated point. The interpolated point is the point
        on the polynomial of degree `points.size() - 1` that passes through all the points in the list. The x-value of
        the interpolated point is the `double` parameter, and the y-value is the return value of the method."

        The problem statement is a major factor in the perceived difficulty of an exercise.
        The difficulty can be adjusted as needed by changing the complexity of the tasks to be completed,
        the associated test cases, the explanation of the tasks, the UML diagram, and/or the thematic story hook.

        Here is the current state of the problem statement:
{{~/system}}

{{#user~}}{{problemStatement}}{{~/user}}

{{#assistant~}}{{instructions}}{{/assistant}}

{{#block hidden=True}}
    {{#system~}}
        You may either rewrite the problem statement from scratch, or replace parts of the existing problem statement.
        If there are only a few minor changes to be made, it is recommended to replace parts of the existing problem statement.
        However, extensive changes may be easier to make by rewriting the problem statement from scratch.
        To rewrite the entire problem statement, respond with the number 1.
        To replace parts of the existing problem statement, respond with the number 2.
    {{~/system}}
    {{#assistant~}}{{gen 'type' max_tokens=2}}{{/assistant}}
{{/block}}

{{#if (contains 'type' '1')}}
    {{#geneach 'changes' num_iterations=1}}
        {{set 'this.type' 'modify'}}
        {{set 'this.file' 'none'}}
        {{set 'this.original' '!all!'}}
        {{#system~}}Rewrite the problem statement.{{~/system}}
        {{#assistant~}}{{gen 'this.updated' temperature=0.5 max_tokens=1000}}{{~/assistant}}
    {{/geneach}}
{{else}}
    {{#geneach 'changes' num_iterations=20}}
        {{set 'this.type' 'modify'}}
        {{set 'this.file' 'none'}}
        {{#system~}}
                Quote some text from the problem statement that you would like to change.
                Respond with the exact text from the original problem statement.
                It is very important that your entire response can be found in the original text.
                Do NOT use quotation marks. Do not justify your response.
            {{#if (not @first)}}
                    Do not select the same part of the problem statement more than once.
                    If you have nothing else to replace, respond with the special response "!done!".
            {{/if}}
        {{~/system}}
        {{#assistant~}}{{gen 'this.original' temperature=0.0 max_tokens=1000}}{{~/assistant}}
        {{#if (equal this.original '!done!')}}
            {{break}}
        {{/if}}
        {{#system~}}This text from the problem statement should be replaced by:{{~/system}}
        {{#assistant~}}{{gen 'this.updated' temperature=0.5 max_tokens=1000}}{{~/assistant}}
    {{/geneach}}
{{/if}}
