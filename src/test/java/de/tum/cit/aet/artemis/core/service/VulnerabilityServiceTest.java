package de.tum.cit.aet.artemis.core.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.List;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpEntity;
import org.springframework.web.client.RestTemplate;

import de.tum.cit.aet.artemis.core.dto.CombinedSbomDTO;
import de.tum.cit.aet.artemis.core.dto.ComponentVulnerabilitiesDTO;
import de.tum.cit.aet.artemis.core.dto.SbomComponentDTO;
import de.tum.cit.aet.artemis.core.dto.SbomDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvBatchResponseDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvPackageDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvVulnerabilityDTO;
import de.tum.cit.aet.artemis.core.dto.osv.OsvVulnerabilityResultDTO;

/**
 * Unit tests for {@link VulnerabilityService}.
 * These tests verify the vulnerability checking, version filtering, and severity extraction logic.
 */
@ExtendWith(MockitoExtension.class)
class VulnerabilityServiceTest {

    @Mock
    private RestTemplate restTemplate;

    @Mock
    private SbomService sbomService;

    @Mock
    private CacheManager cacheManager;

    @Mock
    private Cache cache;

    private VulnerabilityService vulnerabilityService;

    @BeforeEach
    void setUp() {
        vulnerabilityService = new VulnerabilityService(restTemplate, sbomService, cacheManager);
    }

    @Test
    void getVulnerabilities_returnsFromCache_whenCacheHit() {
        // Given
        var cachedResult = new ComponentVulnerabilitiesDTO(null, 5, 1, 2, 1, 1, "2024-01-01T00:00:00Z");
        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(cachedResult);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then
        assertThat(result).isEqualTo(cachedResult);
        assertThat(result.totalVulnerabilities()).isEqualTo(5);
    }

    @Test
    void getVulnerabilities_returnsEmpty_whenNoSbom() {
        // Given
        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(null);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then
        assertThat(result.totalVulnerabilities()).isZero();
        assertThat(result.vulnerabilities()).isEmpty();
    }

    @Test
    void getVulnerabilities_queriesOsvApi_whenCacheMiss() {
        // Given
        var component = createTestComponent("xlsx", "0.20.3", "npm", "pkg:npm/xlsx@0.20.3");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);

        // Mock OSV API response with no vulnerabilities
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of())));
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then
        assertThat(result.totalVulnerabilities()).isZero();
        verify(cache).put(eq("allVulnerabilities"), any(ComponentVulnerabilitiesDTO.class));
    }

    @Test
    void refreshVulnerabilities_evictsCache_beforeFetching() {
        // Given
        var sbom = createCombinedSbomWithComponents(List.of());
        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);

        // When
        vulnerabilityService.refreshVulnerabilities();

        // Then
        verify(cache).evict("allVulnerabilities");
    }

    @Test
    void getVulnerabilities_filtersOutVulnerability_whenVersionIsFixed() {
        // Given
        var component = createTestComponent("xlsx", "0.20.3", "npm", "pkg:npm/xlsx@0.20.3");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        // Create vulnerability that was fixed in 0.20.2 (component version 0.20.3 should NOT be affected)
        var fullVulnerability = createVulnerabilityWithFixedVersion("GHSA-5pgg-2g8v-p4x9", "0.20.2");
        // Batch API returns minimal info (just ID)
        var minimalVuln = createMinimalVulnerability("GHSA-5pgg-2g8v-p4x9");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        // Mock the individual vulnerability API call
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/GHSA-5pgg-2g8v-p4x9"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then - vulnerability should be filtered out since 0.20.3 >= 0.20.2
        assertThat(result.totalVulnerabilities()).isZero();
    }

    @Test
    void getVulnerabilities_includesVulnerability_whenVersionIsAffected() {
        // Given - version 0.19.0 is affected by a vulnerability fixed in 0.20.2
        var component = createTestComponent("xlsx", "0.19.0", "npm", "pkg:npm/xlsx@0.19.0");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        var fullVulnerability = createVulnerabilityWithFixedVersionAndSeverity("GHSA-5pgg-2g8v-p4x9", "0.20.2", "HIGH");
        var minimalVuln = createMinimalVulnerability("GHSA-5pgg-2g8v-p4x9");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/GHSA-5pgg-2g8v-p4x9"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then - vulnerability should be included since 0.19.0 < 0.20.2
        assertThat(result.totalVulnerabilities()).isEqualTo(1);
        assertThat(result.highCount()).isEqualTo(1);
    }

    @Test
    void getVulnerabilities_extractsSeverity_fromDatabaseSpecific() {
        // Given
        var component = createTestComponent("test-package", "1.0.0", "npm", "pkg:npm/test-package@1.0.0");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        // Create vulnerability with database_specific severity but no CVSS
        var fullVulnerability = createVulnerabilityWithFixedVersionAndSeverity("TEST-001", "2.0.0", "CRITICAL");
        var minimalVuln = createMinimalVulnerability("TEST-001");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/TEST-001"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then
        assertThat(result.criticalCount()).isEqualTo(1);
    }

    @Test
    void getVulnerabilities_countsSeveritiesCorrectly() {
        // Given - multiple components with different severity vulnerabilities
        var component1 = createTestComponent("package1", "1.0.0", "npm", "pkg:npm/package1@1.0.0");
        var component2 = createTestComponent("package2", "1.0.0", "npm", "pkg:npm/package2@1.0.0");
        var sbom = createCombinedSbomWithComponents(List.of(component1, component2));

        var fullVuln1 = createVulnerabilityWithFixedVersionAndSeverity("VULN-001", "2.0.0", "CRITICAL");
        var fullVuln2 = createVulnerabilityWithFixedVersionAndSeverity("VULN-002", "2.0.0", "HIGH");
        var minimalVuln1 = createMinimalVulnerability("VULN-001");
        var minimalVuln2 = createMinimalVulnerability("VULN-002");

        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln1)), new OsvVulnerabilityResultDTO(List.of(minimalVuln2))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/VULN-001"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVuln1);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/VULN-002"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVuln2);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then
        assertThat(result.totalVulnerabilities()).isEqualTo(2);
        assertThat(result.criticalCount()).isEqualTo(1);
        assertThat(result.highCount()).isEqualTo(1);
    }

    @Test
    void getVulnerabilities_filtersOutVulnerability_whenLastKnownAffectedVersionRangeIndicatesSafe() {
        // Given - xlsx 0.20.3 with vulnerability that has lastKnownAffectedVersionRange "< 0.19.3"
        // This means only versions < 0.19.3 are affected, so 0.20.3 should NOT be affected
        var component = createTestComponent("xlsx", "0.20.3", "npm", "pkg:npm/xlsx@0.20.3");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        // Create vulnerability with lastKnownAffectedVersionRange but no fixed version
        var fullVulnerability = createVulnerabilityWithLastKnownAffectedRange("GHSA-4r6h-8v6p-xvw6", "< 0.19.3", "HIGH");
        var minimalVuln = createMinimalVulnerability("GHSA-4r6h-8v6p-xvw6");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/GHSA-4r6h-8v6p-xvw6"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then - vulnerability should be filtered out since 0.20.3 >= 0.19.3
        assertThat(result.totalVulnerabilities()).isZero();
    }

    @Test
    void getVulnerabilities_includesVulnerability_whenLastKnownAffectedVersionRangeIndicatesAffected() {
        // Given - xlsx 0.18.0 with vulnerability that has lastKnownAffectedVersionRange "< 0.19.3"
        // This means only versions < 0.19.3 are affected, so 0.18.0 IS affected
        var component = createTestComponent("xlsx", "0.18.0", "npm", "pkg:npm/xlsx@0.18.0");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        var fullVulnerability = createVulnerabilityWithLastKnownAffectedRange("GHSA-4r6h-8v6p-xvw6", "< 0.19.3", "HIGH");
        var minimalVuln = createMinimalVulnerability("GHSA-4r6h-8v6p-xvw6");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/GHSA-4r6h-8v6p-xvw6"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then - vulnerability should be included since 0.18.0 < 0.19.3
        assertThat(result.totalVulnerabilities()).isEqualTo(1);
        assertThat(result.highCount()).isEqualTo(1);
    }

    @Test
    void getVulnerabilities_filtersOutVulnerability_whenLastKnownAffectedVersionRangeWithInclusiveOperator() {
        // Given - version 0.20.3 with vulnerability that has lastKnownAffectedVersionRange "<= 0.20.2"
        // This means versions <= 0.20.2 are affected, so 0.20.3 should NOT be affected
        var component = createTestComponent("xlsx", "0.20.3", "npm", "pkg:npm/xlsx@0.20.3");
        var sbom = createCombinedSbomWithComponents(List.of(component));

        var fullVulnerability = createVulnerabilityWithLastKnownAffectedRange("GHSA-5pgg-2g8v-p4x9", "<= 0.20.2", "HIGH");
        var minimalVuln = createMinimalVulnerability("GHSA-5pgg-2g8v-p4x9");
        var osvResponse = new OsvBatchResponseDTO(List.of(new OsvVulnerabilityResultDTO(List.of(minimalVuln))));

        when(cacheManager.getCache("sbomVulnerabilities")).thenReturn(cache);
        when(cache.get("allVulnerabilities", ComponentVulnerabilitiesDTO.class)).thenReturn(null);
        when(sbomService.getCombinedSbom()).thenReturn(sbom);
        when(restTemplate.postForObject(eq("https://api.osv.dev/v1/querybatch"), any(HttpEntity.class), eq(OsvBatchResponseDTO.class))).thenReturn(osvResponse);
        when(restTemplate.getForObject(eq("https://api.osv.dev/v1/vulns/GHSA-5pgg-2g8v-p4x9"), eq(OsvVulnerabilityDTO.class))).thenReturn(fullVulnerability);

        // When
        var result = vulnerabilityService.getVulnerabilities();

        // Then - vulnerability should be filtered out since 0.20.3 > 0.20.2
        assertThat(result.totalVulnerabilities()).isZero();
    }

    // Helper methods

    private SbomComponentDTO createTestComponent(String name, String version, String type, String purl) {
        return new SbomComponentDTO(null, name, version, type, purl, null, null);
    }

    /**
     * Creates a minimal vulnerability DTO like what the OSV batch API returns.
     * The batch API only returns id and modified date, not full details.
     */
    private OsvVulnerabilityDTO createMinimalVulnerability(String id) {
        return new OsvVulnerabilityDTO(id, null, null, null, null, null, null, null);
    }

    private CombinedSbomDTO createCombinedSbomWithComponents(List<SbomComponentDTO> components) {
        var serverSbom = new SbomDTO("CycloneDX", "1.6", "test-serial", 1, null, components);
        return new CombinedSbomDTO(serverSbom, null);
    }

    private OsvVulnerabilityDTO createVulnerabilityWithFixedVersion(String id, String fixedVersion) {
        return createVulnerabilityWithFixedVersionAndSeverity(id, fixedVersion, null);
    }

    private OsvVulnerabilityDTO createVulnerabilityWithFixedVersionAndSeverity(String id, String fixedVersion, String severity) {
        var event = new OsvVulnerabilityDTO.OsvEventDTO("0", fixedVersion, null);
        var range = new OsvVulnerabilityDTO.OsvRangeDTO("SEMVER", List.of(event));
        var affectedDatabaseSpecific = new OsvVulnerabilityDTO.OsvAffectedDatabaseSpecificDTO(null);
        var affected = new OsvVulnerabilityDTO.OsvAffectedDTO(new OsvPackageDTO(null, "npm", null), List.of(range), affectedDatabaseSpecific);
        var databaseSpecific = severity != null ? new OsvVulnerabilityDTO.OsvDatabaseSpecificDTO(severity) : null;
        return new OsvVulnerabilityDTO(id, "Test vulnerability", "Test details", null, null, List.of(affected), null, databaseSpecific);
    }

    /**
     * Creates a vulnerability with lastKnownAffectedVersionRange in the affected.database_specific field.
     * This simulates GHSA vulnerabilities that don't have a fixed version in the range events
     * but instead use lastKnownAffectedVersionRange to indicate which versions are affected.
     *
     * @param id                            the vulnerability ID
     * @param lastKnownAffectedVersionRange the version range string like "< 0.19.3" or "<= 0.20.2"
     * @param severity                      the severity level (CRITICAL, HIGH, MEDIUM, LOW)
     * @return the created vulnerability DTO
     */
    private OsvVulnerabilityDTO createVulnerabilityWithLastKnownAffectedRange(String id, String lastKnownAffectedVersionRange, String severity) {
        // No fixed version in events - only introduced at "0"
        var event = new OsvVulnerabilityDTO.OsvEventDTO("0", null, null);
        var range = new OsvVulnerabilityDTO.OsvRangeDTO("ECOSYSTEM", List.of(event));

        // Set lastKnownAffectedVersionRange in affected.database_specific
        var affectedDatabaseSpecific = new OsvVulnerabilityDTO.OsvAffectedDatabaseSpecificDTO(lastKnownAffectedVersionRange);
        var affected = new OsvVulnerabilityDTO.OsvAffectedDTO(new OsvPackageDTO(null, "npm", null), List.of(range), affectedDatabaseSpecific);

        // Set severity in vulnerability.database_specific
        var databaseSpecific = severity != null ? new OsvVulnerabilityDTO.OsvDatabaseSpecificDTO(severity) : null;
        return new OsvVulnerabilityDTO(id, "Test vulnerability", "Test details", null, null, List.of(affected), null, databaseSpecific);
    }
}
