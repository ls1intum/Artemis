[
    {
        "fileName": "src/de/test/MergeSort.java",
        "fileContent": "package de.test;\n\nimport java.util.*;\n\npublic class MergeSort implements SortStrategy {\n    \n    /**\n     * Wrapper method for the real MergeSort algorithm.\n     *\n     * @param input the List of Dates to be sorted\n     */\n    public void performSort(List<Date> input) {\n        mergesort(input, 0, input.size() - 1);\n    }\n\n    // Recursive merge sort method\n    private void mergesort(List<Date> input, int low, int high) {\n        if (high - low < 1) {\n            return;\n        }\n        int mid = (low + high) / 2;\n        mergesort(input, low, mid);\n        mergesort(input, mid + 1, high);\n        merge(input, low, mid, high);\n    }\n\n    // Merge method\n    private void merge(List<Date> input, int low, int middle, int high) {\n\n        Date[] temp = new Date[high - low + 1];\n        int leftIndex = low;\n        int rightIndex = middle + 1;\n        int wholeIndex = 0;\n        while (leftIndex <= middle && rightIndex <= high) {\n            if (input.get(leftIndex).compareTo(input.get(rightIndex)) <= 0) {\n                temp[wholeIndex] = input.get(leftIndex++);\n            }\n            else {\n                temp[wholeIndex] = input.get(rightIndex++);\n            }\n            wholeIndex++;\n        }\n        if (leftIndex <= middle && rightIndex > high) {\n            while (leftIndex <= middle) {\n                temp[wholeIndex++] = input.get(leftIndex++);\n            }\n        }\n        else {\n            while (rightIndex <= high) {\n                temp[wholeIndex++] = input.get(rightIndex++);\n            }\n        }\n        for (wholeIndex = 0; wholeIndex < temp.length; wholeIndex++) {\n            input.set(wholeIndex + low, temp[wholeIndex]);\n        }\n    }\n}\n"
    },
    {
        "fileName": "src/de/test/Client.java",
        "fileContent": "package de.test;\n\nimport java.text.*;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic final class Client {\n\n    private static final int ITERATIONS = 10;\n    \n    private static final int RANDOM_FLOOR = 5;\n    \n    private static final int RANDOM_CEILING = 15;\n\n    private Client() {\n    }\n\n    /**\n     * Main method.\n     * Add code to demonstrate your implementation here.\n     *\n     * @param args command line arguments\n     */\n    public static void main(String[] args) throws ParseException {\n\n        // Init Context and Policy\n\n        Context sortingContext = new Context();\n        Policy policy = new Policy(sortingContext);\n\n        // Run multiple times to simulate different sorting strategies\n        for (int i = 0; i < ITERATIONS; i++) {\n            List<Date> dates = createRandomDatesList();\n\n            sortingContext.setDates(dates);\n            policy.configure();\n\n            System.out.print(\"Unsorted Array of course dates = \");\n            printDateList(dates);\n\n            sortingContext.sort();\n\n            System.out.print(\"Sorted Array of course dates = \");\n            printDateList(dates);\n        }\n    }\n\n    /**\n     * Generates a List of random Date objects with random List size between\n     * {@link #RANDOM_FLOOR} and {@link #RANDOM_CEILING}.\n     *\n     * @return a List of random Date objects\n     * @throws ParserException if date string cannot be parsed\n     */\n    private static List<Date> createRandomDatesList() throws ParseException {\n        int listLength = randomIntegerWithin(RANDOM_FLOOR, RANDOM_CEILING);\n        List<Date> list = new ArrayList<>();\n\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"dd.MM.yyyy\");\n        Date lowestDate = dateFormat.parse(\"08.11.2016\");\n        Date highestDate = dateFormat.parse(\"03.11.2020\");\n\n        for (int i = 0; i < listLength; i++) {\n            Date randomDate = randomDateWithin(lowestDate, highestDate);\n            list.add(randomDate);\n        }\n        return list;\n    }\n\n    /**\n     * Creates a random Date within the given range.\n     *\n     * @param low the lower bound\n     * @param high the upper bound\n     * @return random Date within the given range\n     */\n    private static Date randomDateWithin(Date low, Date high) {\n        long randomLong = randomLongWithin(low.getTime(), high.getTime());\n        return new Date(randomLong);\n    }\n\n    /**\n     * Creates a random long within the given range.\n     *\n     * @param low the lower bound\n     * @param high the upper bound\n     * @return random long within the given range\n     */\n    private static long randomLongWithin(long low, long high) {\n        return ThreadLocalRandom.current().nextLong(low, high + 1);\n    }\n\n    /**\n     * Creates a random int within the given range.\n     *\n     * @param low the lower bound\n     * @param high the upper bound\n     * @return random int within the given range\n     */\n    private static int randomIntegerWithin(int low, int high) {\n        return ThreadLocalRandom.current().nextInt(low, high + 1);\n    }\n\n    /**\n     * Prints out the given Array of Date objects.\n     *\n     * @param list of the dates to print\n     */\n    private static void printDateList(List<Date> list) {\n        System.out.println(list.toString());\n    }\n}\n"
    },
    {
        "fileName": "src/de/test/BubbleSort.java",
        "fileContent": "package de.test;\n\nimport java.util.*;\n\npublic class BubbleSort implements SortStrategy {\n    /**\n     * Sorts dates with BubbleSort.\n     *\n     */\n    public void performSort(List<Date> input) {\n        for (int i = input.size() - 1; i >= 0; i--) {\n            for (int j = 0; j < i; j++) {\n                if (input.get(j).compareTo(input.get(j + 1)) > 0) {\n                    Date temp = input.get(j);\n                    input.set(j, input.get(j + 1));\n                    input.set(j + 1, temp);\n                }\n            }\n        }\n\n    }\n}\n"
    }
]
